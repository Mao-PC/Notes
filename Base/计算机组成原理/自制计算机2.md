# 自制计算机 2

## 连续的加法

加法器可以通过封装后得到

![加法器封装](res/加法器封装.png)

加法器有很明显的缺点: 如果是多个数字进行相加, 如 `10 + 8 + 6`, 应该如何进行呢?

加数 1 输入 10 , 加数 2 输入 8, 得到结果为 18, 在加数 1 输入 18 ,加数 2 输入 6, 得到加过 24. **能不能让加法器自己记住中间的结果(18)并自动参与和下一个加数的运算呢?**

首先, 我们对加法器进行改造,如下

![连续的加法](res/连续的加法1.png)

把两个加数合并为一个输入端, 并在加数输入端增加一个边边沿触发器 RA, 触发端为 K<sub>RA</sub>

在计算 `10 + 5` 时:

1. 输入端输入第一个加数 10, 10 会到达 RA 和 加法器下端的输入端
2. 按下 K<sub>RA</sub>, RA 会存储并输出 10, 到达加法器的上端, 此时加法器会输出 20
3. 输入第二个加数 5, 会到达 RA 和 加法器下端的输入端, 不触发 RA, 此时加法器的上面的输入端为 10, 下面为 5, 会输入结果 15

这样我们就已经得到了一个只需要一个输入端的电路.

然后我们在此基础上改造电路如下:

![连续的加法](res/连续的加法2.png)

将加法器的输出端连接到输入端上, 这样就可以使输出结果自动成为下一次的输入参数, 但是这样做有很明显的弊端: **输出结果和原始加法器的下端的输入端成为一个闭环**, 如果使用这个电路进行运算会出现的现象:

输入加数 10, 并按下 K<sub>RA</sub>, 加法器的上端为 10 , 下端为 10, 输出 20, 然后 20 作为第二个加数输入到了加法器下端, 此时加法器上端为 10, 下端为 20, 会输出 30, 然后 30 会作为第三个参数输入 ...

所以结果作为参数输入的过程需要被控制, 对电路进行如下改造:

![连续的加法](res/连续的加法3.png)

图中的 GA 和 GB 是一组继电器, 并且在 GA 闭合时 GB 打开, GB 闭合时 GA 打开. TR 是一个边沿触发器

在计算 `10 + 8 + 6` 的步骤:

1. 输入端输入第一个加数 10, **按住 K<sub>GA</sub>不放**. 10 达到了 RA 和加法器下端
2. 触发 K<sub>RA</sub>, RA 存储并输出 10, 此时加法器输出 20, 由于 K<sub>TR</sub>没有触发, 所以 20 并没有向后输出
3. 输入第二个参数 8, 8 达到了 RA 和加法器下端, 此时加法器上面的输入端为 10, 下面的输入端为 8 ,输出 为 18.
4. 触发 K<sub>TR</sub>, TR 保存并输出了 18
5. **按住 K<sub>GB</sub>不放**, TR 输出的 18 会作为下一个加数到达 RA 和加法器下端, 此时加法器上面的输入端为 10 ,下面为 18 ,输出为 28, 但是 K<sub>TR</sub>没有触发, 所以 28 并没有向后输出
6. 触发 K<sub>RA</sub>, RA 保存并输出了 18, 此时加法器上面的输入端为 18 ,下面为 18 ,输出为 36, 但是 K<sub>TR</sub>没有触发, 所以 36 并没有向后输出
7. 输入端输入第三个加数 6, **按住 K<sub>GA</sub>不放** 6 达到了 RA 和加法器下端, 此时加法器上面的输入端为 18, 下面的输入端为 6 ,输出 为 24.
8. 触发 K<sub>TR</sub>, TR 保存并输出了 24, 运算完成

以上步骤可以总结为:

-   1: 加载, 输入第一个加数(K<sub>GA</sub> - K<sub>RA</sub>)
-   2: 相加, 输入下一个加数, 然后和上一个加数相加, 并将结果存储起来(K<sub>GA</sub> - K<sub>TR</sub>)
-   3: 记忆, 将终结结果保存到加法器上面的输入端, 以备下次的运算(K<sub>GB</sub> - K<sub>RA</sub>)

2 个加数: 1-2
3 个加数: 1-2-3-2
4 个加数: 1-2-3-2-3-2

多输入一个加数就要多进行一次 3-2

## 简化操作

连续的加法在每次输入加数的时候触发操作太多, 需要优化

现在在连续的加法基础上进行如下改造

![简化操作](res/简化操作1.png)

在原型的电路中加入译码器

通过译码器真值表发现, 如果是多个数相加, 第一步加载完成后, 相加和记忆这两步值需要改变 K0 和 K1 这这个值就可以完成

## 先后问题

优化完成电路后, 还有问题, **加载**步骤进行时, 必须是要先闭合 K<sub>GA</sub>, 然后再触发 K<sub>RA</sub>, 如果同时闭合的话就会造成数据不能够存到 RA 里

![先后问题](res/先后问题.png)

因为加法操作中大部分都是在不断的触发 K0 和 K1, 而这些操作就是 1 在 K0 和 K1 直接不停的循环. RR 是一个循环移位寄存器(上升沿)来代替 K0 和 K1 来给译码器输入, 并且在初始状态下 K0 = 1, K1 = 0, 闭合一次 K(触发一次 RR), 它们的值就会交换

加法步骤:

-   输入第一个加数
-   **闭合 `K加载`**, 由于 K0=1, 所以 IGA=1, IRA=1
    -   传输门 GA 打开,数据被传送到了 RA
    -   但是 RA 没有触发, 因为 IRA 要和 K 的另一路输出进行与运算
    -   只闭合了`K加载`, GA 就被打开了
-   K 键:

    -   **按下 K 键**, 会产生两路脉冲
        -   第一路通过非门到达循环位移寄存器, 但是将上升沿变为下降沿, 所以循环位移寄存器并没有触发, 译码器会保持原来输出
        -   第二路到达与 IRA 连接的与门, RA 从 0 变成 1, 产生一个上升沿, 寄存器 RA 被触发, 第一个加数就存到了 RA 中
    -   **松开 K 键**, 会产生一个下降沿, 非门将下降沿变为上升沿, RR 被触发, K0=0, K1=1,这时译码器所有的输出都为 0

我们**通过闭合`K加载`来打开传输门, 按下 K 键来出发寄存器**, 这样就解决了先后问题

尽管现在我们已经解决了加载操作, 但是还需要**再按**一次 K 键:

-   按下的时候

    -   第一路不会触发 RR 寄存器.
    -   第二路输出, 因为译码器输出的全都是 0, 所以也不会触发任何一个寄存器

    也就是说, 在按下的时候不会产生任何作用

-   松开的时候, 会触发 RR, 使得 K0=1. K1=0

这也是我们的目的所在, 是**RR 恢复到初始状态**, 因为下一步是要输入第二个加数进行相加:

-   输入第二个加数
-   断开**K 加载**, 闭合**K 相加**
    -   由于 K0= 1, 所以 IGA=1, ITR=1
    -   传输门 GA 打开, 数据进入加法器并和第一个加数进行相加, 并且结果输入到了 TR 门口, 但是 TR 没有触发, 因为 ITR 还需要和按键 K 的另一路输出进行与运算
-   K 键
    -   **按下 K 键**
        -   因为非门存在, 所以 RR 没有触发
        -   但是 RA 被触发，因为按键 K 的第二路输出和 IRA 做与运算. 被触发后，RA 将中间结果存储在了加法器中
    -   **松开 K 键**
        -   RR 被触发，使得 K0=1、K1=0. RR 又重新回到了最初始的状态，为下一次相加操作做好了准备

综上, 我们现在步骤变成了:

-   闭合 K 加载, 点 2 下 K 键, 完成第一个加数的加载
-   断开 K 加载, 闭合 K 相加, 点 2 下 K 键, 完成第二个参数的相加和记忆

    点 2 下 K 键, 完成第三个参数

    ...

    点 2 下 K 键, 完成第 N 个参数的相加

-   最后一个加数相加为止, 最终的结果被存储到了 RA 中

改电路运行的特点:

1. 闭合 K 加载或 K 相加, 就会打开某一个传输门. 因为 K0 和 K1 的值不需要手动设置
2. 必须按下 K 按键，寄存器才会被触发. 因为，与寄存器相连的输出端要和 K 的输出进行与运算. 所以，不按下 K，寄存器是不会被触发的

现在，我们不但解决了先后的问题，而且进一步简化了操作.
因为，K0、K1 这两个开关被 K 这一个开关取代了.
之前，我们需要对 K0 和 K1 这两个开关进行操作.
而现在，我们的大部分操作基本上就变成了不断地输入加数，然后点击按键 K 就可以了

## 先存储再计算

之前我们的电路已经完了自动的加法计算, 在加载完成第一个加数后闭合 K 相加, 每次都点 2 次 K 键完成相加. 但是加数还是要每次手动输入, 现在来解决加数的输入问题

![先存储再计算](res/先存储再计算1.png)

上图为这个电路中使用的 16 位存储器, 本地拿了中只用 5 路, 所以只使用了前 5 位, 分别存储了 5 个加数

读端口 R = 1. 通过地址端口数据来读取不同的地址的数据. 每取一个数就要更改一次, 如果需要读取的数据很多就需要不停的更改, 这显然是很麻烦的. 能不能通过修改电路来使这个通过自动更改吗?

![先存储再计算](res/先存储再计算2.png)

AC: 最初始的时候为 0, 每触发 K<sub>AC</sub>一次就加一. 为存储器提供地址, 所以叫做地址计数器

AR: 是用来存储地址的, AC 的数据通过 AR 转为地址传递给 RAM 存储器, 被称为地址寄存器

K<sub>R</sub>是向存储器发送读取命令的. 闭合 K<sub>R</sub>存储器就执行读取操作, 把数据传输到 DR

K<sub>DR</sub>就是触发 DR, 保存数据

这样的话读取一个数据的步骤就有: 写入地址 ==> 读出数据 ==> 刷新地址

需要 3 个步骤才能读出一个数据, 需要对电路进一步优化:

![先存储再计算](res/先存储再计算3.png)

使用循环移位寄存器(RR)配合译码器来做优化.

RR 的初始值: K0=1, K1=0, K2=0

-   按下 K 键, 输出 1
    -   第一路, 由于非门存在, 上升沿变为下降沿, 不会触发 RR
    -   第二路, 进行与运算 AR: 0 => 1, AR 被触发, 完成第一步, **写入地址**
-   松开 K 键, 输出 0
    -   第一路, 下降沿 => 上升沿, RR 被触发, K0=0, K1=1, K2=0, 根据真值表, IR = 1, IDR = 1
    -   第二路, 进行与运算, DR = 0. IR = 1, 存储器进行了读取操作, 数据输出到了 DR 存储器
-   按下 K 键, 输出 1
    -   第一路, RR 输出不变
    -   第二路, 运行与运算, DR = 1, IR 不变, RD 被触发, 完成第二步, **读出数据**
-   松开 K 键, 输出 0
    -   第一路, RR 被触发, K0=0, K1=0, K2=1, 根据真值表, IAC = 1
    -   第二路, 进行与运算, 不会做任何操作
-   按下 K 键, 输出 1
    -   第一路, RR 不变
    -   第二路, 进行与运算, AC: 0 => 1, AC 被触发, AC 加一. 完成了第三步, **刷新地址**
-   松开 K 键, 输出 0, **恢复到初始状态**

这样, 每点 3 次, 就完成了一次读取操作

最后, 将存储器电路接入就变成了

![先存储再计算](res/先存储再计算4.png)

这样就不需要手动一个个的把加数输入到加法器中

## 全自动计算

上面我们已经完成了存储加数和相加操作, 只需要 K 加载, K 相加, K 键 3 个按钮就可以完成

我们需要改造电路进一步优化

![全自动计算](res/全自动计算.png)

IR 是一个普通的寄存器, 用来临时存储指令的, 叫做指令寄存器. 有 N 个输入(N 为主线的位数), 两个输出, 输出到译码器, 分别代表了 `K 加载`和 `K 输出`

存储器也要做相应的改变. 如图中, 在第一个加数前要有加载指令, 后面每个加数前都要有相加指令, 即每个加数前都要有个指令码来标识下个加数要执行的是加载还操作是相加操作

相加操作的执行过程省略...

这样, 我们就只需要不停的点击 K 键就可以执行加法操作, 如果这是把 K 键改为一个震荡器, 就可以全自动执行操作

![全自动计算](res/全自动计算2.png)

组合后就是

![全自动计算](res/全自动计算3.png)

这个 振荡器+RR 就是之前的跑马灯

到此为止, 我们就完成了一个计算机的雏形:

-   RAM 存储器, 就是内存, 存储着指令和数据. 存储单元 **存储器**
-   指令存储器 IR + 指令译码器 + 译码器 = 控制单元 **控制器**, `IR` 从内存中取出指令传输给`指令译码器`, `指令译码器`将跟据指令设置`译码器`, `译码器`会根据指令以指令译码器不同的设置来输出不同的控制信号, 这些控制信号连接着不同的固件[ AG, AR, DR, GA, RA, TR, GB ]
-   GA + RA + TR + GB + 加法器 = 算数逻辑单元 **计数器**
-   算数逻辑单元 + IR + 指令译码器 + 译码器 + 一些零碎的控制固件(AG, AR, DR) = **CPU**

## 计算机的选择

计算机在执行指令时, 并不是逐条执行的, 计算机也就根据不同的指令进行 **"选择"**

如, 在 5 位加法器中, 有可能会发生**进位**而产生第 6 位的情况, 这时, 就需要将这个进位标志(第六位端口)输入到译码器中, 而译码器就可以**根据不同的标志来输出不同的结果**, 这就是计算机的"选择". 这个进位标志就是一种**标志位**

![计算机的选择](res/计算机的选择.png)

译码器是如何做"选择"的呢?

译码器不只是有加载指令和相加指令, 还会有**跳转指令**. 计算机会根据跳转指令来跳转到指定的位置执行, 而不是按照原型的顺序执行

计算机的"选择"就是依靠 `标志位 + 跳转指令` 实现的

至此, 自制计算机的内存完结
