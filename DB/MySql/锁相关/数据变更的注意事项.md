[toc]

# 数据变更的注意事项



在写 SQL 时, 数据库会隐式的为 SQL 语句加上各种各样的锁, 导致我们数据库变更时会遇到很多问题

- 碰到表锁了
- 碰到行级锁了
- 事务执行太长了
- 数据量太大了



## 生成环境改表结构



现版本的InnoDB在修改表结构时, 会导致表被锁而无法对外提供服务

可以使用 `pt-online-schema-change` 来修改

处理思路:

1. 新建一模一样的 `_new` 表
2. 新表执行更改字段的操作
3. 原表上加三个触发器, DELETE/UPDATE/INSET
4. 原表数据拷贝到新表中, 然后替换原表



这种方法的缺陷: 如果在表上本身就是有很多触发器, 就会很难做



在后续的版本中, InnoDB会提供一个新特性用于修改表结构时达到秒级, 

现版本慢的最主要原因是要修改数据, 为表中所有的数据都要修改改字段. 解决思路大概为, 为表结构和数据都添加版本号, 如

为表 A 添加字段后, 原先的表结构是v1, 会将表结构修改并标记为v2. 后面插入的数据也会标记为V2, 这样在查询时, 如果发现数据版本为 V1, 会去查到V2的表结构然后为数据补充修改



## Insert 导致的死锁



在数据库 user 表中, name列上存在唯一索引, 在三个session中都开启事务

1. 插入数据 `insert into user values(null, 'tom', 23);`
2. 此时`session 1`显示成功, `session 2` `session 3` 阻塞

此时, `session 1` 会为这行记录加上**间隙锁**, 由于是唯一索引, 所以不会锁住一片, 只会锁住一行数据, `session 2` `session 3` 在插入数据时因为有唯一索引, 就会去加**读锁**, `session 1`事务没有提交导致加锁阻塞

1. `session 1` 回滚
2. `session 2` 插入成功, `session 3` 显示死锁错误

这里`session 1` 回滚同一时间 `session 2` `session 3` 加读锁成功发现可以插入数据, 并加写锁. 此时改数据上已经有了2个读锁, 在数据**有读锁时不能加写锁**, 想要加写锁就要等待其他session把读锁释放,  `session 2` `session 3`都要新增数据, 所以都不会释放读锁, 从而造成**死锁**

由于MySQL的死锁检查机制会导致其中一个 session成功, 其他的失败



这里可以去使用MySQL 提供的更新插入语法来解决, 类似于 HashMap 的如果key存在则更新value



## Update 导致的死锁



user表中有如下数据

```
+----+------+-----+
| id | name | age |
+----+------+-----+
| 10 | m    |  18 |
| 11 | www  |  18 |
| 12 | 222  |  18 |
+----+------+-----+
3 rows in set (0.00 sec)
```

 开启事务执行

1. `session 1` 执行 `update user set age = 20 where age >= 18`
2. `session 2` 执行 `update user set age = 20 where age >= 18` 此时由于 `session 1` 未提交, 所以 `session 2` 阻塞
3. `session 1` 执行 `insert into user values(9, 'tom', 20)`  事务仍未提交, 此时 `session 2`显示了死锁异常提示

<font color="red"> 这里是不是说明了InnoDB锁不可重入 ? </font>

`session 2` 阻塞说明在等 `session 1` 释放锁, 而 `session 2`在执行 `insert` 语句使需要等待 `session 1` 释放锁, 所以检测出死锁 `session 2`

如果在第 3 步执行的是 `insert into user values(20, 'tom', 20)` 就不会有问题, 因为间隙锁没有锁住 `id` 为 20 的数据