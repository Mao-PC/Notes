[TOC]

## MySQL 逻辑架构

![](https://images2018.cnblogs.com/blog/1411859/201806/1411859-20180617123859211-1860022440.png)

-   第一层，即最上一层，所包含的服务并不是 MySQL 所独有的技术。它们都是服务于 C/S 程序或者是这些程序所需要的 ：连接处理，身份验证，安全性等等。
-   第二层是 MySQL 的核心部分。MySQL 数据库的核心服务都是这一层完成的，包括权限判断， sql 解析，行计划优化， query cache 的处理以及所有内置的函数(如日期,时间,数学运算,加密)等等。
    各个存储引擎提供的功能都集中在这一层，如存储过程，触发器，视图等
-   第三层包括了存储引擎。也就是底层数据存取操作实现部分，由多种存储引擎共同组成。它们负责存储和获取所有存储在 MySQL 中的数据。
    每个存储引擎都有自己的优点和缺陷。服务器是通过存储引擎 API 来与它们交互的。这个接口隐藏了各个存储引擎不同的地方。对于查询层尽可能的透明。这个 API 包含了很多底层的操作。如开始一个事务，或者取出有特定主键的行。
    **存储引擎不能解析 SQL(InnoDB 是个例外, 它会解析外键定义, 因为 MySQL 服务器本身没有实现该功能)，互相之间也不能通信。仅仅是简单的响应服务器的请求。**

### 连接管理与安全性

每个客户端连接都会在服务器中有一个线程, 这个连接的查询只会在本线程中单独进行, 而服务器会缓存线程, 因此不需要为每个新建立的连接重新创建或销毁线程.

当客户端连接到 MySQL 服务器时,服务器会对其进行验证, 如果连接成功会继续验证该客户端是否有执行某个特定查询的权限

### 优化与执行

MySQL 会解析查询并创建内部数据结构(解析树), 然后会对其进行各种优化, 包括重新查询, 决定表的读取顺序已经选择合适的索引等. 在[查询性能优化](查询性能优化.md)中我们会讨论更多的优化细节

优化器并不关心使用的是什么存储引擎, 但存储引擎对优化器是有影响的. 优化器会请求存储引擎提供容量或者某个具体操作的开销信息以及表数据的统计信息等. 例如某些存储引擎某种索引会对一些特定查询有优化, 具体请参考[Schema 与数据类型优化](Schema与数据类型优化.md)和[创建高性能的索引](创建高性能的索引.md)

对 select 语句, 在解析查询前会先检查查询缓存(Query Cache), 如果能找到对应的查询, 服务器就会直接返回缓存中的结果集 **MySQL8 已经移除了缓存模块**, 因为我们很少去使用同一条 SQL 去反复查询

## 并发控制

这节制讨论**服务器层**和**存储引擎层**的并发控制

### 读写锁

**读锁**是共享的, 或者说是互相不阻塞的. 多个客户端在同一时间读取同一个资源而互不干扰.

**写锁**是排他的, 也就是说一个写锁会阻塞其他的写锁和读锁. 只有这样才能保证在给定的时间里, 只有一个用户能执行写入并防止其他用户读取正在写入的同一资源

### 锁粒度

理想的方式是只对修改的数据片进行精确锁定. 在给定的资源上, 锁定的数据量越少, 系统的并发程度就越高.

问题是加锁本身也是需要消耗资源的. 锁的各种操作, 包括获取锁, 检查锁是否解除, 释放锁等, 都会增加系统的开销, 如果花费大量的时间来管理锁而不是存取数据那么系统性能很可能会因此受到影响

所谓的锁策略就是在锁的开销和数据的安全性直接寻求平衡. 大多数商业数据库没有提供更多的选择一般情况下都是在表上施加行级锁(row-level lock)

MySQL 中提供了多种选择. 每种 MySQL 存储引擎都可以实现自己的锁策略和锁粒度

#### 表锁(table lock)

**表锁是 MySQL 中的最基本的锁策略, 并且是开销最小的策略**

表锁会锁定整张表. 一个用户对表进行写操作前需要先获得表锁, 这回阻塞其他用户对改表的读写操作. 只有没有写锁时, 其他用户才会获得读锁, 读锁直接是不相互阻塞的

在特定的场景中表锁也会有很好的性能. 例如, `READ LOCAL` 表锁支持某些类型的并发写操作. 另外写锁也比读锁有更高的优先级, 因此一个写锁请求可能会被插入到读锁的队列前面.

存储引擎可以管理自己的锁, MySQL 本身还是会使用各种有效的表锁来实现不同的目的. 例如服务器会为诸如 `ALTER TABLE` 之类的语音使用表锁而忽略存储引擎的锁机制

#### 行级锁(row lock)

**行级锁可以很大程度地支持并发处理, 同时也带来了最大的锁开销**

InnoDB 和 XtraDB 以及其他的一些存储硬气中实现了行级锁, 行级锁只在存储引擎层实现, 而 MySQL 服务器层没有实现

## 事务

假设一个银行有两张表: 支票表(checking) 和 储蓄表(savings). 现在一个用户要从支票账户中转移 200 到储蓄账户中, 那么至少需要三个步骤:

1. 检查支票账户中余额是否高于 200
2. 从支票账户中 -200
3. 在储蓄账户中 +200

上述 3 个步骤必须打包在同一个事务中, 任何一个步骤失败都必须回滚所有步骤

```sql
START TRANSACTION;
SELECT balance FROM checking WHERE customer_id = 12138;
UPDATE checking SET balance = balance - 200.00  WHERE customer_id = 12138;
UPDATE savings SET balance = balance + 200.00  WHERE customer_id = 12138;
COMMIT;
```

一个能够进行良好的事务处理系统, 必须具备**ACID**标准特性

-   原子性 (atomicity) 一个事务被视为一个不可分割的最小单元, 整个事务必须要么全部成功要么全部失败
-   一致性 (consistency) 数据库总是从一个一致性状态转换到另一个一致性状态. 在前面的例子中, 及时是在执行第三第四条语句之间系统崩溃因为事务没有提交, 所做的修改也不会保存到数据库中
-   隔离性 (isolation) 一个事务所做的修改在最终提交之前, 对其他事务是不可见的
-   持久性 (durability) 一旦提交了事务, 所做的修改就会拥挤保存到数据库中. 及时系统崩溃修改的数据也不会丢失

就像锁粒度的升级会增加系统开销一样, 这种事务的处理过程额外的安全性也会需要数据库做很多额外的工作. 对于一些不需要事务处理的查询, 可以选择非事务型的存储引擎以获得更高的性能.

即使存储引擎不支持事务, 也可以通过 `LOCK TABLES` 语句为应用提供一定程度的保护, 这些选择用户都可以自主决定

### 隔离级别

SQL 中定义了 4 中标准隔离级别

-   READ UNCOMMITED (读未提交)

    事务中的修改即使没有提交对其他事务也是可见的.

    **事务可以读取未提交的数据, 被称为脏读**

    从性能上来说, 这个级别不会比其他级别好太多, 但却缺乏其他级别的很多好处, 在实际中很少用到

-   READ COMMITED (读已提交)

    大多数数据库的默认隔离级别. 简单的来说就是**一个事物开始时, 只能"看到"已经提交的事物所做的修改**, 换句话说就是一个事物从开始到提交之前, 所做的任何修改对其他事务都是不可见的.

    这个级别有时候也叫`不可重复读(nonrepeatable read)`, 因为执行两次同样的查询很可能会得到不同的结果

-   REPEATABLE READ (可重复读)

    解决了脏读的问题, 改级别保证了在同一个事务中多次读取同样记录的结果是一致的.但是还是无法解决幻读问题

    幻读, 是当摸个事务在读取某个范围的数据记录时, 另一个事务又在该范围插入了新的记录, 当事务再次读取该范围记录时, 会产生幻行(Phantom Read)

    **可重复读是 MySQL 的默认事务隔离级别**, InnoDB 和 XtraDB 存储引擎通过版本并发控制(MVCC) 解决了幻读问题

-   SERIALIZABLE (可串行化)

    最高的隔离级别. 通过其强制事务串行, 避免了前面说的幻读问题. 改解绑会在读取每一行数据都加上锁, 所以会导致大量的超时和锁争用的问题. 实际上很少用的这个级别.

| 隔离级别        | 脏读 | 不可重复读 | 幻读 | 加锁读 |
| --------------- | ---- | ---------- | ---- | ------ |
| READ UNCOMMITED | yes  | yes        | no   | no     |
| READ COMMITED   | no   | yes        | no   | no     |
| REPEATABLE READ | no   | no         | no   | yes    |
| SERIALIZABLE    | no   | no         | no   | no     |

### 死锁

当多个事务同时锁定了同一个资源时, 会产生死锁

事务一

```sql
START TRANSACTION
UPDATE StockPrice SET close = 45.5 WHERE stock_id = 3 and date = '2020-1-1';
UPDATE StockPrice SET close = 20 WHERE stock_id = 4 and date = '2020-1-2';
COMMIT;
```

事务二

```sql
START TRANSACTION
UPDATE StockPrice SET close = 45.5 WHERE stock_id = 4 and date = '2020-1-2';
UPDATE StockPrice SET close = 20 WHERE stock_id = 3 and date = '2020-1-1';
COMMIT;
```

事务一和事务二就很有可能产生死锁, **InnoDB 目前处理死锁的方法是吗将持有最上行级排他锁的事务进行回滚**, 死锁发送以后只有部分或者完全回滚其中一个事务, 才能打破死锁

### 事务日志

存储引擎在修改数据时只需要修改其内存拷贝, 再把修改行为记录到硬盘上的事务日志中, 而不用每次都把修改的数据本身持久到硬盘

事务支出采用的是追加的方式, 写日志是磁盘上一小块顺序 IO 而不是随机 IO, 所以相对会快很多. 大多数存储引擎都是这样实现的, 通常被称为预写式日志(Write-Ahead Logging), 修改数据需要写两次磁盘

如果数据的修改意见记录到了事务日志并持久化, 但是数据本身还没写到磁盘, 此时系统崩溃, 存储引擎在重启是能自动修复这部分数据

### MySQL 中的事务

MySQL 默认使用**自动提交(AUTOCOMMIT)**, 可以通过 `show variables like 'autocommit'` 来查看当前是否为自动提交模式, 1 或者 ON 表示启用, 0 或 OFF 表示禁用

有一些命令在执行前, 即使 AUTOCOMMIT 模式处于关闭也会也会自动提交当前事务. 如 DDL 中, 会导致大量数据改变的操作, 如 `ALTER TABLE`

MySQL 可以通过 `SET TRANSACTION ISOLATION LEVEL` 来配置隔离级别

> **在事务中混合使用存储引擎**

MySQL 服务层不管理事务, 事务是由下次的存储引擎来实现的, 所以在同一个事务中, 使用多种存储引擎是不可靠的.

如果在事务中混合使用了 InnoDB(事务型)和 MyISAM(非事务型)在正常提交是不会出现问题. 但是如果回滚事务, 非事务型的表就无法撤销变更, 回滚才会发出一个警告: `""某些非事务型的表上的变更不能被回滚`

> **隐式和显示锁定**

InnoDB 采用两阶段锁定协议. 在事务执行过程中随时都可以执行锁定, 锁只有在执行 COMMIT 或者 ROLLBACK 时才会释放, 并且所有的锁在同一实际释放. 这些都是 MySQL 更加隔离级别自动加锁, 也就是隐式锁定

还可以通过特点的 SQL 语句来显示锁定:

```sql
SELECT ... LOCK IN SHARE MODE
SELECT ... FOR UPDATE
```

p.s. 这些锁应当尽量避免使用

## 多版本并发控制 MVCC

不仅仅是 MySQL, 包括 Oracle, postgreSQL 也都实现了 MVCC

MVCC 也可以被认为是行级锁的变种, 在很多情况下避免了加锁操作, 因此开销更低.

InnoDB 的 MVCC 是通过每行记录后面保存两个隐藏列来实现的. 这两个列, 一个保存了行的创建时间, 一个保存了行的过期时间. 当然存储的并不是时间的时间值, 而是系统版本号

> 在 REPEATABLE READ 隔离级别下, MVCC 是如何工作的

-   SELECT:

    InnoDB 会更加一下两个条件检查每行记录:

    1. InnoDB 只查找版本早于当前事务版本的数据行(行的系统版本号小于等于事务的系统版本号)
    2. 行的删除号要么未定义,要么大于当前事务版本号,这样可以确保事务读取到的行,在事务开始之前未被删除.

    只有符合上述两个条件的记录才能做法查询结果返回

-   INSERT:
    InnoDB 为新插入的每一行保存当前系统版本号做为行版本号。

-   DELETE:
    INNODB 为删除的每一行保存当前系统版本号作为行删除标识

-   UPDATE:
    InnoDB 为插入的每一行新记录,保存当前系统版本号作为行版本号,同时保存当前系统版本号到原来的行作为行删除标识.

MVCC 只在 REPEATABLE READ 和 READ COMMITED 两个工作级别下工作

## MySQL 的存储引擎

可以使用`SHOW TABLE STATUS` (在 5.0 以后可以查询 `INFORMATION_SCHEMA` 中对应的表)显示表的相关信息

### InnoDB

采用了 MVCC 来支持高并发, 实现了四个标准的隔离级别, 默认为 REPEATABLE READ, 并且通过间隙所(next-key locking)策略来方式幻读出现.

InnoDB 表是基于聚簇索引建立的, 后续章节会详细讨论. 聚餐索引对主键查询有很高的性能.

### MyISAM

在 5.1 之前 MyISAM 是 MySQL 默认的存储引擎. 提供了大量的特性, 包括全文索引, 压缩, 空间函数(GIS)等, 但是**不支持事务和行级锁**

MyISAM 会将表存储在两个文件中: 数据文件(以.myd 结尾)和索引文件(以.myi 结尾)

> MyISAM 压缩表

如果在创建并导入数据以后, **不会再进行修改操作**, 那么这样的表或许比较适合采用 MyISAM 压缩表, 可以极大地减少磁盘占用, 也可以销售磁盘 IO. 从而提升查询性能.

压缩表也支持索引, 但是索引也是只读的

压缩表中的记录时独立压缩的, 所以读取单行的时候不需要去解压整个表,(甚至也不解压所在的整个页面)

### 其他引擎

略

### 选择合适的引擎

如果需要不同的存储引擎请先考虑一下几个因素

-   事务
    如果需要指出事务, InnoDB(或者 XtraDB)是目前最稳定且经过验证的选择

-   备份
    如果需要在线热备份, 选 InnoDB

-   奔溃恢复
    MyISAM 崩溃后损坏概率要比 InnoDB 高很多, 而且恢复速度也慢. 所以即使不需要支持事务, 很多人也选择 InnoDB

-   特有的特性
    有些应用可能依赖一些存储引擎独有的特性或者优化, 如很多依赖聚簇索引优化. MyISAM 支持地理空间搜索

一下对具体的应用建议:

-   **日志型应用**

    这类应用对插入速度有很高的要求, MyISAM 或者 Archive 存储引擎就比较合适, 因为开销低, 且插入速度非常快

    但是如果需要对日志进行**报表分析**, 生产报表的 SQL 很有肯会导致插入的效率明显减低, 那么应该怎么办 ?

    1. 主从复制, 读写分离, 这样就不会因为要读取而导致插入的效率变低
    2. 在日志表的名字中包含年月信息, 比如 web_logs_2020_01 或者 lamp_logs_2020_10, 这样就可以在没有插入操作的表上进行频繁的查询操作, 而不会干扰到新表上的插入操作

-   **只读或者大部分情况下只读的表**

    如果**不介意崩溃修复**问题的话选择 MyISAM 是最合适的

    但是经验采用 InnoDB, MyISAM 在一开始可能没有任何问题, 但随着应用压力上升会迅速恶化, 各种锁竞争, 崩溃后数据丢失问题随之而来

-   **订单处理**

    必须支持事务, 选择 InnoDB

-   **电子公告牌和主题讨论论坛**

    这类应用大多数倾向于在一次请求中执行尽可能多的查询语句. 多数应用只设计了**几张表来保存所有的数据, 所以核心表的读写压力可能非常大**, 为了保证核心表的数据一致性, 锁成为资源竞争的主要因素. 由于这些设计缺陷, 大多数应用在低负载时可以工作的很好, 但是如果 web 站点迅速扩张, 流量随之猛增, 数据库访问会非常缓慢

-   **CD-ROM 应用**

    考虑使用 MyISAM 或者 MyISAM 压缩表, 这样表之间可以隔离并且可以在不同介质上相互拷贝

-   **大数据量**

    如果数据在 10TB 以上级别可能需要建立数据仓库. Infobright 是 MySQL 数据仓库最成功的解决方案. 有些大数据库不合适 Infobright, 却可能适合 TokeDB

### 转换表的引擎

将表的存储引擎换成另一种, 这样会**失去和原引擎相关的所有特性**. 例如一张 InnoDB 的表转为 MyISAM, 然后在转回 InnoDB, 所有的外键会丢失

有很多方法, 这里举 3 个方法:

1. **ALTER TABLE**

    是最简单的方法 `ALERT TABLE mytable ENGINE = InnoDB;`

    缺陷: 需要执行**很长时间**. MySQL 会将数据从原表复制到一张新表中, 在复制期间会消耗系统 IO 同时在原表上加读锁, 在繁忙的表上执行需要特别小心

2. **导入和导出**

    使用 mysqldump 工具将数据导出到文件, 然后修改文件中的 `CREAT TABLE` 语句中的存储引擎.

    可以避免方法 1 中的问题

    注意:

    1. 修改表名, 同一个数据库中不能存在表名相同的表
    2. mysqldump 会自动在 `CREAT TABLE` 语句前加上 `DROP TABLE` 语句, 小心数据丢失

3. 创建于查询

改方法综合了方法 1 的高效和方法 2 的安全. 先创建一个新的表, 然后使用 `INSERT ... SELECT`语法来导数据

```sql
CREATE TABLE InnoDB  Innodb_table LIKE myisam_table;
ALTER TABLE Innodb_table ENGINE = InnoDB;
INSERT INTO Innodb_table SELECT * FROM myisam_table;
```

数据量很大, 则可以考虑分批处理
