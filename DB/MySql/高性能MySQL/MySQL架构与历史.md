[TOC]
## MySQL逻辑架构

![](https://images2018.cnblogs.com/blog/1411859/201806/1411859-20180617123859211-1860022440.png)

- 第一层，即最上一层，所包含的服务并不是MySQL所独有的技术。它们都是服务于C/S程序或者是这些程序所需要的 ：连接处理，身份验证，安全性等等。
- 第二层是MySQL的核心部分。MySQL数据库的核心服务都是这一层完成的，包括权限判断， sql解析，行计划优化， query cache 的处理以及所有内置的函数(如日期,时间,数学运算,加密)等等。
各个存储引擎提供的功能都集中在这一层，如存储过程，触发器，视图等
- 第三层包括了存储引擎。也就是底层数据存取操作实现部分，由多种存储引擎共同组成。它们负责存储和获取所有存储在MySQL中的数据。
每个存储引擎都有自己的优点和缺陷。服务器是通过存储引擎API来与它们交互的。这个接口隐藏了各个存储引擎不同的地方。对于查询层尽可能的透明。这个API包含了很多底层的操作。如开始一个事务，或者取出有特定主键的行。
**存储引擎不能解析SQL(InnoDB 是个例外, 它会解析外键定义, 因为 MySQL 服务器本身没有实现该功能)，互相之间也不能通信。仅仅是简单的响应服务器的请求。**

### 连接管理与安全性

每个客户端连接都会在服务器中有一个线程, 这个连接的查询只会在本线程中单独进行, 而服务器会缓存线程, 因此不需要为每个新建立的连接重新创建或销毁线程. 

当客户端连接到MySQL服务器时,服务器会对其进行验证, 如果连接成功会继续验证该客户端是否有执行某个特定查询的权限

### 优化与执行

MySQL会解析查询并创建内部数据结构(解析树), 然后会对其进行各种优化, 包括重新查询, 决定表的读取顺序已经选择合适的索引等. 在[查询性能优化](查询性能优化.md)中我们会讨论更多的优化细节

优化器并不关心使用的是什么存储引擎, 但存储引擎对优化器是有影响的. 优化器会请求存储引擎提供容量或者某个具体操作的开销信息以及表数据的统计信息等. 例如某些存储引擎某种索引会对一些特定查询有优化, 具体请参考[Schema与数据类型优化](Schema与数据类型优化.md)和[创建高性能的索引](创建高性能的索引.md)

对select语句, 在解析查询前会先检查查询缓存(Query Cache), 如果能找到对应的查询, 服务器就会直接返回缓存中的结果集 **MySQL8已经移除了缓存模块**, 因为我们很少去使用同一条SQL去反复查询

## 并发控制

这节制讨论**服务器层**和**存储引擎层**的并发控制

### 读写锁

**读锁**是共享的, 或者说是互相不阻塞的. 多个客户端在同一时间读取同一个资源而互不干扰.

**写锁**是排他的, 也就是说一个写锁会阻塞其他的写锁和读锁. 只有这样才能保证在给定的时间里, 只有一个用户能执行写入并防止其他用户读取正在写入的同一资源

### 锁粒度

理想的方式是只对修改的数据片进行精确锁定. 在给定的资源上, 锁定的数据量越少, 系统的并发程度就越高.

问题是加锁本身也是需要消耗资源的. 锁的各种操作, 包括获取锁, 检查锁是否解除, 释放锁等, 都会增加系统的开销, 如果花费大量的时间来管理锁而不是存取数据那么系统性能很可能会因此受到影响

所谓的锁策略就是在锁的开销和数据的安全性直接寻求平衡. 大多数商业数据库没有提供更多的选择一般情况下都是在表上施加行级锁(row-level lock)

MySQL中提供了多种选择. 每种MySQL存储引擎都可以实现自己的锁策略和锁粒度

#### 表锁(table lock)

**表锁是MySQL中的最基本的锁策略, 并且是开销最小的策略**

表锁会锁定整张表. 一个用户对表进行写操作前需要先获得表锁, 这回阻塞其他用户对改表的读写操作. 只有没有写锁时, 其他用户才会获得读锁, 读锁直接是不相互阻塞的

在特定的场景中表锁也会有很好的性能. 例如, `READ LOCAL` 表锁支持某些类型的并发写操作. 另外写锁也比读锁有更高的优先级, 因此一个写锁请求可能会被插入到读锁的队列前面.

存储引擎可以管理自己的锁, MySQL本身还是会使用各种有效的表锁来实现不同的目的. 例如服务器会为诸如 `ALTER TABLE` 之类的语音使用表锁而忽略存储引擎的锁机制

#### 行级锁(row lock)

**行级锁可以很大程度地支持并发处理, 同时也带来了最大的锁开销**

InnoDB 和 XtraDB以及其他的一些存储硬气中实现了行级锁, 行级锁只在存储引擎层实现, 而MySQL服务器层没有实现

## 事务

假设一个银行有两张表: 支票表(checking) 和 储蓄表(savings). 现在一个用户要从支票账户中转移200到储蓄账户中, 那么至少需要三个步骤: 

1. 检查支票账户中余额是否高于200
2. 从支票账户中 -200
3. 在储蓄账户中 +200

上述3个步骤必须打包在同一个事务中, 任何一个步骤失败都必须回滚所有步骤

```sql
START TRANSACTION;
SELECT balance FROM checking WHERE customer_id = 12138;
UPDATE checking SET balance = balance - 200.00  WHERE customer_id = 12138;
UPDATE savings SET balance = balance + 200.00  WHERE customer_id = 12138;
COMMIT;
```

一个能够进行良好的事务处理系统, 必须具备**ACID**标准特性

- 原子性 (atomicity) 一个事务被视为一个不可分割的最小单元, 整个事务必须要么全部成功要么全部失败
- 一致性 (consistency) 数据库总是从一个一致性状态转换到另一个一致性状态. 在前面的例子中, 及时是在执行第三第四条语句之间系统崩溃因为事务没有提交, 所做的修改也不会保存到数据库中
- 隔离性 (isolation) 一个事务所做的修改在最终提交之前, 对其他事务是不可见的
- 持久性 (durability) 一旦提交了事务, 所做的修改就会拥挤保存到数据库中. 及时系统崩溃修改的数据也不会丢失

就像锁粒度的升级会增加系统开销一样, 这种事务的处理过程额外的安全性也会需要数据库做很多额外的工作. 对于一些不需要事务处理的查询, 可以选择非事务型的存储引擎以获得更高的性能.

即使存储引擎不支持事务, 也可以通过 `LOCK TABLES` 语句为应用提供一定程度的保护, 这些选择用户都可以自主决定

### 隔离级别

SQL中定义了4中标准隔离级别

- READ UNCOMMITED (读未提交)

    事务中的修改即使没有提交对其他事务也是可见的.

    **事务可以读取未提交的数据, 被称为脏读**

    从性能上来说, 这个级别不会比其他级别好太多, 但却缺乏其他级别的很多好处, 在实际中很少用到

- READ COMMITED (读已提交)

    大多数数据库的默认隔离级别. 简单的来说就是**一个事物开始时, 只能"看到"已经提交的事物所做的修改**, 换句话说就是一个事物从开始到提交之前, 所做的任何修改对其他事务都是不可见的.

    这个级别有时候也叫`不可重复读(nonrepeatable read)`, 因为执行两次同样的查询很可能会得到不同的结果