[TOC]

# Schema 与数据类型优化

本章内容是为接下来的两张做铺垫, 在这 3 章中, 我们将讨论逻辑设计, 物理设计和查询执行, 以及它们的相互作用

## 选择优化的数据类型

选择数据类型的原则:

-   更小的通常更好

    更小的数据类型通常更快, 因为它们占用更少的磁盘, 内存和 CPU, 并且处理需要的 CPU 周期也越少

    但是要确保没有低估需要存储的范围, 因为在 schema 中的多个地方增加数据类型的范围是非常耗时且痛苦的

-   简单就好

    简单的数据类型操作通常需要更少的 CPU 周期. 例如应该使用 MySQL 内建的类型(date, time, datetime)而不是字符串来存储日期和时间. 应该使用整型存储 IP 地址

-   尽量避免 NULL

    很多表都包含可为 NULL 的列. 如果在查询中包含可以为 NULL 的列, 对于 MySQL 来说是很难优化, 索引,索引统计和值比较都更为复杂. 使用更多的存储空间, 在 MySQL 中需要特殊处理, 当可以为 NULL 的列被索引时, 每个索引需要额外的字节来记录.

    同常把可为 NULL 的列改为 NOT NULL 带来的性能提升很小, 所以在优化时没有优先修改这种情况

在为列选择数据类型时通常分为两步:

1. 需要确定合适的大类型: 数组, 字符串, 时间等
2. 选择具体的类型. 如 datetime 和 timestamp

### 整数类型

| 类型                | TINYINT | SMALLINT | MEDIUMINT | INT | BIGINT |
| ------------------- | ------- | -------- | --------- | --- | ------ |
| 空间占用 (单位: 位) | 8       | 16       | 24        | 32  | 64     |

存储的值范围为 **2<sup>N-1</sup> ~ 2<sup>N-1</sup>-1**, N 是存储空间位数

整数类型有可选的 UNSIGNED 属性, 表示不允许负值, 这大致可以使正数的上限提高一倍, 如 TINYINT UNSIGNED 的存储范围是 0 ~ 255, 而 TINYINT 为 -128~127

有符号和无符号类型使用相同的空间, 且具有相同的性能

不同类型决定了 MySQL 是怎么在内存和磁盘上保存数据的. 然而正数计算一般使用 64 位的 BIGINT 正数, 即时在 32 位环境中也如此

MySQL 可以**为整数类指定宽度**, 如 INT(11), 对于大多数应用**这是没有意义**的: 它不会限制值的合法范围, 只是规定了在一些交互工具中显示的字符个数

### 实数类型

实数类型就是带有小数部分的数组, MySQL 既支持精确类型, 又支持不精确类型

`FLOAT` 和 `DOUBLE`支持使用标准的浮点运算进行**近似计算**

`DECIMAL` 类型用于精确计算. CPU 不支持对 `DECIMAL` 的直接运算, MySQL 自身的实现. 相对而言, CPU 直接支持原生浮点运算, 所以浮点运算的效率更高

`浮点`和 `DECIMAL` 都可以指定精度.

-   对于 `DECIMAL` 列,可以指定小数点前后所允许的最大位数, 这会影响列的空间消耗. `DECIMAL` 类型最大允许存储 65 个数字

-   有很多种方法可以修改**浮点列**所需要的精度, MySQL 会悄悄选择不同的护甲类型或者在存储时对值进行取舍. **建议只指定数据类型, 不指定精度**

浮点类型在存储相同范围的值时通常比 DECIMAL 使用更少的空间. FLOAT 使用 4 个字节, DOUBLE 使用 8 个.

**因为需要额外的空间和计算开销, 所以尽量在只对小数进行精确计算时使用 DECIMAL, 例如财务数据**. 但是数据量比较大时, 可以考虑使用 BIGINT 来代替 DECIMAL (将小数乘以 10 的 N 次方来存储为整数), 这样同样可以避免存储计算不精确和 DECIMAL 精确计算代价高的问题

### 字符串

> **VARCHAR 和 VAR**

-   VARCHAR 存储可编程字符串, 它比定长类型更节省空间, 因为它仅使用必要的空间

    varchar 需要使用 1 或 2 个额外字节来记录字符串长度: 如果列的最大长度小于等于 255 那就只需要 1 个字节表示.

    varchar 节省了空间, 对性能也有所帮助. 但是由于行是变长的, 在 update 时可能导致需要额外的工作

    适用 varchar 的情况:

    -   字符串列的最大长度比平均长度大很多
    -   列更新很少, 所以碎片不是问题
    -   使用了像 utf-8 这样的复杂字符集, 每个字符都适用不同 字节进行存储

-   CHAR 类型是定长的, char 值会采用空格进行填充以方便比较

    使用 char 的情况:

    -   很短的字符串, 或者所有值长度都接近同一个长度, 例如 密码的 MD5
    -   经常变更的数据, 不容易产生碎片
    -   对于短的列, char 比 varchar 空间利用率更高, 例如 char(1) 只存储 Y 或者 N 的值, 使用单字节字符集只需要一个字节, varchar(1)需要 2 个, 因为还需要一个字节记录长度

与 char 和 varchar 类似的类型还有 `binary` 和 `varbinary`, 它们存储的是二进制字符串

```
慷慨是不明智的

使用varchar(5)和varchar(100)存储字符串 'hello' 空间开销是一样的, 但是更长的列会消耗更多的内存, 因为MySQL通常会分配固定大小的内存来存储内部值, 尤其使用内存临时表排序或者操作时会特别糟糕

所以最好值分配真正需要的空间
```

> **BLOB 和 TEXT 类型**

BLOB 和 TEXT 都是为存储很大的数据而设计字符串数据类型, 分别采用**二进制和字符串**方式存储

实际上, 字符型是 `TINYTEXT, SAMLLTEXT(TEXT), MEDIUMTEXT, LONGTEXT` 二进制是 `TINYBLOB, SAMLLBLOB(BLOB), MEDIUMBLOB, LONGBLOB`

与其他类型不同, MySQL 把每个 BLOB 和 TEXT 值都当做一个独立的对象来处理. 在 InnoDB 中, 如果 BLOB 和 TEXT 值太大是, 会在外部存储区存储, 每个值在行内存储 1~4 个字节的指针

BLOB 和 TEXT 不同: BLOB 存储的是二进制数据, 没有排序规则或者字符集

MySQL 不能将 BLOB 和 TEXT 列全部长度的字符串进行索引, 也不能使用这些索引消除排序

尽量避免使用 BLOB 和 TEXT

> **使用枚举(ENMU)代替字符串类型**

MySQL 的枚举类型存储时**非常紧凑, 可以压缩到一个或者两个字节中**. MySQL 内部会将每个值在列表中的位置保存为整数, 并且在表的 `.frm` 文件中保存 `数子-字符串`映射关系的"查找表"

枚举自动是按照内部存储的整数而不是定义的字符串进行排序的, 如: 创建了枚举 `fish apple dog` MySQL 内部存储为 `1 2 3`, 在排序时是按照数子来排序, 而不是按照`apple dog fish` 的字母书写来排序

枚举的缺点是: **字符串列表是固定的, 添加或者删除字符串必须要使用`ALTER TABLE`**

在同时使用 enum 和 varchar 列进行关联查询时会比使用只 varchar 关联查询慢很多, 但是值使用 enum 进行关联查询会很快

将 varchar 转为 enum 存储可以让表的大小缩小很多, 在某些情况下, 即使困难会出现 enum 和 varchar 关联的情况, 也是值得的 (可能会节省 IO)

> **使用时间和日期类型**

MySQL 存储**最小时间粒度为秒**(MariaDB 支持微秒)

-   DATETIME

    范围是 1001 ~ 9999 年, 精度为秒. 与**时区无关**, 使用 8 个字节的存储空间

-   TIMESTAMP

    保存了从 1970 年 1 月 1 日午夜(格林尼治标准时间)依赖的秒数, 和 Unix 时间戳相同. **依赖于时区**, 使用 4 个字节的存储空间, 默认为 `NOT NULL`

在多个时区存储和访问 timestamp 和 datetime 的行为很不一样. 通常**应该尽量使用 TIMESTAMP**

**如果需要存储比秒更小粒度的时间怎么办?**

-   可以使用`bigint`存储微秒级别时间戳, 或者使用 `double` 存储秒之后的小数部分
-   也可以使用 MariaDB 来代替 MySQL 来达到目的

> **位数据类型**

-   BIT

    bit 在 MYSQL 5.0 之前就是 `TINYINT`

    可以使用 bit 在一列中存储一个或多个 true/false 值 bit(1)包含一个位, bit(2) 存储两个位, 最多可以由 64 个位

    bit 的行为因存储引擎而异, 有很多令人费解的行为, 应该**尽量避免使用**

-   SET

    可以保存很多 true/false 值, 可以有效的利用空间

    缺点**改变定义的代价太高, 需要 ALTER TABLE**

> **选择标识符 (identity)**

一旦选定了一种类型, 要确保在所有的关联表中都使用相同的类型, 在可以满足值的范围的需求并且预留未来增城空间的前提下, 应该选择最小的数据类型

一些小技巧:

-   整数类型:

    通常是**最好的选择**, 因为很快而且可以使用 `AUTO_INCREMENT`

-   ENUM 和 SET :

    通常是很糟糕的, 但是对某些只包含固定状态或者类型的静态 "定义表" 是没问题的. 如有序的状态, 产品类型, 性别

-   字符串
    尽量**避免使用**, 很耗空间而且比数字慢. 对于一些随机的字符串如 MD5, SHA1, UUID, 会任意分布在很大空间, 到导致一些 insert 和 select 语句变得很慢:

    -   插入的索引会随机的写到不同的位置, 使得 insert 很慢. 导致页分裂, 磁盘随机访问已经对于聚簇索引产生索引碎片
    -   逻辑上相邻的行会分布到内存和磁盘上不同的地方, 导致 select 很慢
    -   随机值缓存导致对所有类型的查询语句效果都差

-   如果使用 UUID 应该尽量去除 '-', 或者更好的做法是使用 `UNHEX()`函数转换 UUID 值为 16 字节数字

## MySQL schema 设计中的陷阱

一些典型缺陷:

-   太多的列

    MySQL 的存储引擎 API 工作时需要在服务器层和存储引擎层之间通过进行缓冲格式拷贝数据, 然后在服务器层将缓冲内容解码成各个列. 从行缓冲中将编码过的列转成行数据结构的操作代缴是非常高的

-   太多的关联

    MySQL 限制了每个关联操作最多只能有 61 张表. 一个经验法则最好在 12 张表内做关联

-   全能的枚举

    要防止过度使用枚举

-   变相的枚举
-   非次发明(Not Invent Here)的 NULL
    上面讲述了不使用 null 的好处, 应该尽可能的考虑替代方案, 但是不能走极端. 比如使用一连串 0 来代替 null

## 范式和反范式

### 范式的优缺点

优点:

-   范式化的更新操作通常会比反范式化要快
-   数据较好的范式化, 就只会有很少的重复数据, 索引只需要修改更少的数据
-   范式化的表通常更小, 可以很好的防止内存里, 执行操作会更快
-   很少有多余的数据意味着检索列表数据更少需要 `DISTINCT` 或者 `GROUP BY`

缺点: 通常需要关联, 稍微复杂一些的语句需要至少一次的关联

### 反范式的优缺点

优点: 可以很好的避免关联, 对于查询最差的情况 -- 全表扫描也要比观察快的多

### 混用范式和反范式

完全的范式化或者反范式化在实际中是很少看到的, **最常见的反范式化数据方法是复制或者缓存**, 在不同表里存储相同的特定列

## 缓存表和汇总表

优势提高性能最好的办法是在同一张表中保存衍生的冗余数据, 有时也需要一张完全独立的汇总表汇总缓存表

例如, 在一个很繁忙的网站, 需要及时之前 24 小时发生的消息数. 可以没小时生成一张汇总表

### 物化视图

物化视图实际上是预习计算并且存储在磁盘上的表, 可以通过各种各样的策略刷新和更新.

<font color='red'>MySQL 不原生支持物化视图</font>, 可以使用 Justin Swanhart 的开源工具 `Flexviews`来实现

### 计数器表

假设有一个计数器表, 只有一行数据, 记录网站的点击次数. 这条记录上有一个全局的互斥锁, 这回使得事务只能串行

可以将数据保存到多行中, 每次随机选择一行进行更新. 比如预先在这个表中增加 100 行数据, 每次增加都随机选择一行进行更新, 在获取统计结果时可以使用`count()`来统计

另一个常见需求是每隔一段时间就开始一个新的计数器(例如每天一个), 这样可以不想前面那样预先生成, 使用`ON DUPLICATE KEY UPDATE (当insert已经存在的记录时，执行Update)` 代替, 如果希望减少表的行数以避免条变得太大, 就可以写一个定时任务,合并所有结果为 0 的槽并且删除所有其他槽

```
更快的读, 更慢的写

为了提升查询速度, 经常需要一些额外的索引, 增加冗余列, 甚至创建缓存表和汇总表

这些方法增加了写操作的负担, 也需要额外的维护, 但是显著提高了查询速度

但是写操作变慢不是唯一的代价, 可能还同时增加了读操作和写操作的开发难度
```

## 加快 ALTER TABLE 操作的速度

MySQL 在修改表结构的操作方法是用新的结构建一个空表, 从旧表中查出所有数据插入新表, 然后再删除新表. 这可能会消耗很长时间, 一般来说, `ALTER TBALE` 操作导致服务中断

能使用的技巧:

1. 先在一台不提供服务的机器上执行`ALTER TBALE`, 然后和提供服务的主库进行切换
2. "影子拷贝", 用要求表结构创建一张和原表无关的新表, 然后通过重命名和单彪操作交换两张表

不是所有的`ALTER TBALE` 都会引起表重建, 有两种方可以**改变或删除一个列的默认值**:

1. `MODIFY COLUMN` 会拷贝整张表到一张新表(重建表). 操作会很慢
2. `ALTER COLUMN` 会直接修改 `.frm` 文件(列队默认值会报错到该文件)而不设计表数据, 这个操作时非常快的

### 只修改 .frm 文件

值修改表的`.frm`文件是很快的, 但是 MySQL 有时汇总没有必要的情况下重建表, 所以在愿意冒风险的情况下, 可以让 MySQL 做一些其他类型的修改而不用重建表, <font color="red">官方不支持且没有文档记录, 进行这些操作需要自身承担风险</font>

-   移除(不是增加)一个累的 `AUTO_INCREMENT`属性
-   增加,移除或者更改 ENUM 和 SET 的常量. 如果移除的是已经有行数据用到了这些值的常量会返回一个空字符串

基本步骤是为想要的表结构创建一个新的`ifrm`文件, 然后用它替换掉原先的文件

1. 创建一张有相同结构的空表, 并进行所需修改
2. 执行`FLUSH TABLES WITH READ LOCK`, 这回关闭所有正在使用的表, 并且禁止任何表被打开
3. 交互`.frm`文件
4. 执行 `UNLOK TABLES`是否第二步的读锁

### 快速创建 MyISAM 索引

为了高效的载入数据可以 先禁用索引, 载入数据, 然后重新启用索引:

```sql
ALTER TABLE test.load_data DISABLE KEYS;
-- load the data
ALTER TABLE test.load_data ENABLE KEYS;
```

这样做会快很多并且使得索引树的碎片更少更紧凑

不幸的是, 这个办法对唯一索引无效, 因为`DISABLE KEYS` 针对非唯一索引有效

在 InnoDB 中可以先删除所有的非唯一索引,然后新增新的列, 最后重新创建删除掉的索引(Percona Server 可以自动完成这一步骤)

<font color="red">下面所讲述的内容官方不支持且没有文档记录, 进行这些操作需要自身承担风险</font>

对于大表来说, 可以这样做:

1. 用需要的表结构创建一张表, 但是不包括索引
2. 载入数据到表中以创建 `.MYD` 文件
3. 按照需要的结构创建另外一张空表, 这次要包含索引. 这回创建需要的 `.frm`文件
4. 获取读锁并刷新表
5. 重命名第二张表的`.frm`和 `.MYD` 文件, 让 MySQL 认为是第一张表的文件
6. 释放读锁
7. 使用 `REPART TABLE` 来重建表的索引. 改操作会通过排序来构建所有索引, 包括唯一索引
