[TOC]

# 服务器性能剖析

## 性能优化简介

在本节中, **性能是指完成某件任务所需要的时间量度, 也就是说, 性能即响应时间.**

优化 --> 降低响应时间

-   优化不一定会降低 CPU 利用率, CPU 利用率上升有可能说了数据库对资源的利用率上升了

-   用每秒查询量的提升来衡量是否被优化, 这其实只是吞吐量优化, 是性能优化的副产品(也有将优化定义为吞吐量的提升, 但是本书中不这样定义). 因为响应时间降低才导致的吞吐量提升

### 通过性能剖析进行优化 (profiling)

性能剖析一般有两个步骤:

1. 策略任务所花费的时间
2. 对结果镜像统计和分析, 将任务排到前面

实际讨论两种类型的性能剖析:

-   基于执行时间的分析
-   基于等待的分析

### 理解性能剖析

性能剖析除了**排名, 总计和平均值**还有很多东西是值得注意的:

-   值得优化的查询 (worthwhile query)

    1. 一些只占用总响应时间的比重很小的查询是不值得优化的
    2. 如果优化的成本大于收益, 就应当停止优化

-   异常情况

    某些任务没有出现性能剖析输出时也需要优化, 例如: 某些任务执行次数很少, 但是每次执行都很慢,, 因为其执行频率低所以总的影响占比不突出

-   未知的未知

    一款好的性能剖析工具有可能会显示"丢失的时间". 丢失的时间指的是任务的总时间和实际测量到的时间直接的差

-   被掩饰的细节 (这里就不知道怎么解释了)

## 对应用程序进行性能剖析

对于整个应用可能导致的性能问题有很多:

-   外部资源, 比如调用了外部的 web 服务器或者搜索引擎
-   应用需要处理大量的数据, 比如分析一个超大的 xml 文件
-   在循环中调用昂贵的操作, 比如执行正则表达式, 或者循环调用 rpc 接口
-   使用了低效的算法

> 性能剖析会导致服务器变慢吗?

是的, 性能剖析的确会导致应用变慢一点, 但是性能剖析可以帮助应用变得更快 :

-   如果没有性能剖析很容易碰到无法提前预知的性能瓶颈
-   发现问题时, 如果有历史数据, 那么这些历史数据的价值就是无限的
-   性能剖析可以帮助规划硬件采购, 资源分配, 已经预测周期性的性能尖峰

这里推荐一个性能剖析工具 **New Relic**. 可以全天候的测量生产环境的代码

## 剖析 MySQL 查询

### 剖析服务器负载

定位和优化"坏"查询能够显著的提升应用性能, 降低服务器的整体压力, 减少对共享资源的争用. 降低服务器的负载也可以推迟或者避免昂贵的应将需求, 还可以发现和定位糟糕的用户体验

> **捕获 MySQL 的查询到日志文件中**

在 MySQL 当前版本中, 慢查询日志是开销最低, 精度最高的测量查询时间工具. **开销可以忽略不计, 更需要担心的是日志可能消耗大量的磁盘空间, 如果长期开启慢查询, 要注意部署日志轮转工具, 或者不要长期开启, 只在需要收集负载样本期间再开启**

如果因为某些原因如权限不足等, 无法在服务器上记录查询, Percona Toolkit 中的`pt-query-digest` 可以由两种替代技术:

-   通过 `--processlist` 选项不断查看 `SHOW FULL PROCESSLIST` 的输出, 但是有可能无法捕获到所有的查询, 一些执行比较快的查询在两次捕获之间就执行完成了
-   通过抓取 TCP 网络包, 然后通过 MySQL 的客户端/服务端通信协议进行解析. 可以通过 tcpdump 将网络包保存到磁盘, 然后使用 pt-query-digest 的`type=tcpdump`来解析并分析

> **分析查询日志**

强烈建议利用慢查询日志捕获服务器上 的所有查询并进行分析, 但是**不要**直接打开整个慢查询日志进行分析, 应该生成一个剖析报告,然后查看入职用需要特别关注的部分. 生成报告建议使用`pt-query-digest`

### 剖析单条查询

定位到需要修改的单条查询后, 需要针对查询"钻取"更多信息, 在实际的应用中除了 `SHOW STATTUS` `SHOW PROFILE` `检查慢查询日志` (最好是 Percona Server, 官方的 MySQL 慢查询日志中缺少了很多附加信息) 之外没有更改的办法了

> **SHOW PROFILE**

MySQL5.1 版本引入, 默认禁用, 可以通过 `SET profiling = 1;` 启用. 在服务器上执行的所有语句都会测量耗时, 会生成一张临时表. 如: 使用 SQL `SELECT * FROM sakial.nicer_but_film_list` 查询, 使用`SHOW PROFILE`来查看临时表

| Query_ID | Duration    | Query                                     |
| -------- | ----------- | ----------------------------------------- |
| 1        | 0.167679000 | SELECT \* FROM sakial.nicer_but_film_list |

可以通过 `SHOW PROFILE FOR QUERY 1` 来查看具体的 Query_ID = 1 的查询执行的每个步骤及其话费的时间

> **SHOW STATTUS**

MySQL 的`SHOW STATTUS`返回了一些计数器. 既有服务器基本的全局计数器也有机遇某个连接的会话级别计数器. 使用 `SHOW GLOBAL STATTUS`可以查看服务器基本的从服务器启动时开始计算的查询基础统计. 不同的计数器看见的范围不一样, 不过全局计数器也会出现哎 `SHOW STATTUS`的结果中,容易被误会为会话级别的.

`SHOW STATTUS` 是一个很有用的工具, 但是**不是一款剖析工具**. 大部分结果都只是一个计数器, 可以显示某些活动中读索引的频繁程度, 但无法给出消耗了多少时间

`SHOW STATTUS`本身也会穿件临时表, 而且通过句柄方法此临时表会影响到 `SHOW STATTUS`结果中对应的数字, 而且在不同版本中也不尽相同

通过 `EXPLAIN` 查看查询的执行计划也可以获得大部分相同的信息, 但是 `EXPLAIN` 通过估计得到的结果, 而通过计数器得到的则是时间的测量结果

> **使用慢查询日志**

... 这里书上好像没怎么说

### 使用性能剖析

得到服务器或者查询的剖析报告后怎么使用? 好的剖析报告能将潜在的问题显示出来. 这里只是引出话题, 后续章节会继续讨论

## 诊断间歇性问题

比如系统偶尔停顿或者慢查询, 很难诊断. 邮箱幻影问题只在没有注意到时才发生, 而且无法确认如何重现. **尽量不要使用试错的方式来解决问题**, 下面列举一些间歇性数据库性能问题解决案例:

-   通过 curl 从一个运行的很慢的外部服务来获取汇率报价的数据
-   memcached 中的一些重要条目过期, 导致大量请求落到 MySQL 以重新生成缓存条目
-   DNS 查询偶尔有超时现象
-   可能是由于互斥锁的争用, 或者内部删除查询缓存的算法效率太低, MySQL 的查询缓存优势会导致服务有短暂的停顿
-   当并发度超过某个阈值时, InnoDB 的扩展性现在导致查询集合的优化需要很长时间

可以看出有个问题是数据库导致的 但是有些不是. 给出我们解决间歇性问题的方法和工具才是"王道"

### 单挑查询问题还是服务器问题

如何判断是单挑查询问题还是服务器问题呢?

如果问题不停的周期性出现, 那么可以在某次活动中观察到. 或者整夜运行脚本收集数据, 第二天分析结果. 大多数情况都可以通过三种技术来解决

> **SHOW GLOBAL STATUS**

这个方法实际上就是以较高频率比如一秒执行一次`SHOW GLOBAL STATUS`命令来捕获数据, 问题出现时, 则可以通过某些计数器的"尖刺"或者"凹陷"来发现. 这个方法比较简单, 所有人都可以用(不需要特殊权限), 对服务器影响也很小, 所以花费时间不多却能很好的了解问题

> **SHOW PROCESSLIST**

不停地捕获`SHOW PROCESSLIST`的输出, 来观察是否有大量线程处于不正常的状态或者有其他不正常的特征.

查询很少会长时间处于 "statistics" 状态, 这个状态一般是指服务器在查询优化阶段如何确定表管理的顺序 -- 通常是非常快的

也会很少见到大量线程报告当前连接用户是 "未验证用户(Unauthorized user)", 这只在连接握手的中间过程中的状态, 当客户端等待输入用于登录的用户信息的时候才会出现

一个经典的例子是很多查询处于`Locked`状态, 这是 MyISAM 的一个经典问题, 它的表级锁定在写请求较多时, 可能迅速导致服务器基本的线程堆积

> **使用查询日志**

需要开启慢查询日志并在全局级别设置 `long_query_time` 为 0, 要确认所有的连接都采用了新的设置. 这可能需要**重启所有连接**以使新的全局设置生效

某些原因不能设置慢查询日志记录所有查询, 也可通过`tcpdump`和`pt-query-digest`工具来模拟代替.

要注意找到吞吐量突然下降时间段的日志, 查询在完成阶段才写入到慢查询日志, 所以堆积会造成大量查询处于完成阶段,直到阻塞其他查询的资源占用者是否资源后, 其他的查询才能执行完成. 这种行为的一个好处就是当吞吐量突然下降时, 可以归咎于吞吐量下降完成的第一个查询(有时候也不一定是第一个查询. 当某些查询被阻塞时, 其他查询可以不接受影响继续运行)

> **理性发现的问题**

可视化数据最优说服力.

我们建议在诊断问题时先使用`SHOW STATUS` 和 `SHOW PROCESSLIST`. 这两种开销很低, 而且可以通过捷安达的 shell 脚本或者反复执行的查询来交互式的收集数据

### 捕获诊断数据

当初间歇性问题时, 需要尽可能多的手机所有数据, 而不是只在问题出现时的数据. 虽然这样会收集大量的诊断数据,但总比真正能诊断问题的数据没有收集到的情况要好

1. 一个可靠且实时的"触发器", 也就是能区分什么时候问题出现的方法
2. 一个收集诊断数据的工具

> **诊断触发器**

有个常见的问题可能导致无法达到预期的结果: `误报`或者`漏检`, 所以在开始收集数据之前多花一些时间来确认触发器能够真正的识别问题是划算的

好的触发器的标准:

-   在出现问题时会比较敏感, 而没有什么问题时则比较平稳
-   `SHOW PROCESSLIST`中线程的异常状态也是个不错的指标
-   `SHOW INNODB STATUS` 的特定输出, 服务器的平均负载尖峰等

关键是找到一些能和正常时的阈值进行比较的指标. **选择一个合适的阈值很重要**, 既要足够高, 以确保在正常时不会被触发, 有不能太高要确保问题发生时不会错过

如: Threads_connected 偶尔出现非常高的尖峰值, 在几分钟之内就会从 100 冲到 5000 或更高, 所以设置 4999 也可以捕获到问题, 但是如果在正常时一般不超过 150, 将阈值设置为 200 或者 300 会更好

如果 Threads_running 的例子, 正常情况下的并发度不超过 10, 但是阈值设置为 10 不是一个好主意, 很可能会导致很多误报, 当线程到 15 时也会有可能会有少量的线程堆积但是可能还没有到问题的引爆点, 建议将阈值设置为 20

> **需要收集什么样的数据**

包括系统的状态, CPU 利用率, 磁盘使用率和可用空间, ps 的输出采样, 内存利用率, 以及可以从 MySQL 活动的信息, 如 SHOW STATUS, SHOW PROCESSLIST 和 SHOW INNODB STATUS 等

**执行时间包括用于工作的时间和等待的时间**, 一般来说一个问题发生时有两种可能:

-   服务器需要做大量的工作, 从而导致大量消耗 CPU
-   在等待某些资源的释放

**剖析报告用于确认是否有太多工作, 等待分析用于确认是否在大量等待**

对于工作时间

-   在 GUN/Linux 平台可用于服务器内部诊断的一个重要工具是 `oprofile`.
-   也可以使用 `strace` 剖析服务器系统掉, 但是在生产环境中使用它有一定风险.
-   如果要剖析查询, 可以使用 `tcpdump`
-   大多数 MySQL 无法方便的打开和关闭慢查询日志, 此时可以通过静态 tcp 流量来模拟

对于等待分析

-   常用的方法是 GDB 的堆栈跟踪. 使用 GDB 是有入侵性的, 他会暂时造成服务器停顿, 有时可能会造成崩溃, 但是如果服务器已经无法提供服务了, 那么使用 GDB 也就无所谓了
-   也可以使用 `SHOW PROCESSLIST` 和 `SHOW INNODB STATUS`的快照信息观察线程和事务状态

这里推荐一个工具`pt-collect`

> **解释结果数据**

建议先根据两个目来查看:

1. 检查问题是否真的发生了, 如果是误报就会白白浪费大量的时间
2. 是否有非常明显的跳跃性变化, 查看一次的查询或者事务行为以及一次的服务器内部行为通常都是最有收获的

    - 查询或者事务的行为可以显示是否由于使用服务器的方式导致的问题: 性能低下的 SQL, 使用了不当的所有, 谁糟糕的数据库逻辑架构等

    - 通过抓取 TCP 流量或者`SHOW PROCESSLIST`输出可以获得查询和事务出现的地方
    - 通过服务器的内部行为可以清楚服务器是否有 bug, 或者内部的性能和扩展性是否有问题

### 案例 (略)

## 其他剖析工具

### 使用 USER_STATISTICS 表

Percona Server 和 MariaDB 都引入了额外的堆积级别使用统计的 `INFOMATION_SCHEMA` 表

这些表可以对数据库获得进行测量和审计, 并且强制执行使用策略. 另外在查找性能问题时, 这些表也可以帮助找出数据库中山门地方花费了最多的时间,或者什么表或索引使用得最频繁, 抑或最不频繁

-   可以查找使用的最多或者使用的最少的表和索引, 通过调取次数或更新次数, 或者两者一起排序
-   可以插在出从未使用的索引, 可以考虑删除
-   可以看看复制用户的`CONNECTED_TIME`和`BUSY_TIME`, 已确定是否会很难更是主库的进度

### 使用 strace

略
