[TOC]

# 回溯算法

回溯法又称试探法, 当试探到某一步时, 发现原来的选择达不到目标, 就退回一步重新选择, 这种走不通就退回再走的技术被称为回溯法

![回溯](res/回溯.png)

## 子集

https://leetcode-cn.com/problems/subsets/

给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

```
示例:
输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```

```java
package com.example.test.alg;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

/**
 * 功能描述: 子集
 *
 * @auther: pikaqiu
 * @date: 2019/5/16 12:26 PM
 */
public class ddd {

    public static void main(String[] args) {

        int[] nums = new int[]{1, 2, 3};

        List<List<Integer>> list = new ArrayList<>();
        Stack<Integer> item = new Stack<>();


        generate(nums, item, list, 0);

        list.add(new ArrayList<>());

        System.out.println(list);
    }

    private static void generate(int[] arr, Stack<Integer> item, List<List<Integer>> list, int start) {

        if (start == arr.length) {
            return;
        }

        item.add(arr[start]);
        List<Integer> item1 = new ArrayList<>();
        item1.addAll(item);
        list.add(item1);

        generate(arr, item, list, start + 1);

        item.pop();

        generate(arr, item, list, start + 1);
    }
}
```

## 求无重复子集

给定一组含重复元素的整数数组 nums，返回该数组所有可能的子集。

例如: nums = \[2,1,2,2]

结果为: \[[],[1],[1,2],[1,2,2],[1,2,2,2],[2],[2,2],[2,2,2]]

注意: [2,1,1] 与 [1,2,2]是重复的

思路: 排序后去重

```java
package com.example.test.alg;

import java.util.*;

/**
 * 功能描述: 求无重复子集
 *
 * @auther: pikaqiu
 * @date: 2019/5/16 12:26 PM
 */
public class Test {

    public static void main(String[] args) {

        int[] nums = new int[]{2, 1, 2, 2};

        List<List<Integer>> list = new ArrayList<>();
        List<Integer> item = new ArrayList<>();

        generate(nums, item, list, 0);

        list.add(new ArrayList<>());

        System.out.println(list);
    }

    private static void generate(int[] arr, List<Integer> item, List<List<Integer>> list, int start) {

        if (start == arr.length) {
            return;
        }

        item.add(arr[start]);
        List<Integer> item1 = new ArrayList<>();
        item1.addAll(item);
        item1.sort(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o1 - o2;
            }
        });
        if (!isEquals(item1, list)) {
            list.add(item1);
        }

        generate(arr, item, list, start + 1);

        item.remove(item.size() - 1);
        generate(arr, item, list, start + 1);
    }

    private static boolean isEquals(List<Integer> item, List<List<Integer>> list) {

        if (list != null && list.size() > 0) {
            for (List<Integer> l : list) {
                boolean flag = false;
                if (l.size() == item.size()) {
                    for (int i = 0; i < item.size(); i++) {
                        if (item.get(i) != l.get(i)) {
                            flag = false;
                            break;
                        } else {
                            flag = true;
                        }
                    }
                }
                if (flag) return true;
            }
        } else {
            return false;
        }

        return false;
    }
}
```

## 组合数之和

给定一组含重复元素的整数数组 nums，求该数组所有可能的子集中, 子集各个元素之和为 target 的子集, 结果中无重复子集。

例如: nums = \[10, 1, 2, 7,6,1,5] target = 8, 结果为: \[[1,7], [1,2,5], [2,6], [1,1,6]]

思路: 这里和上题思路一致, 多加一个判断

```java
package com.example.test.alg;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

/**
 * 功能描述: 组合数之和
 *
 * @auther: pikaqiu
 * @date: 2019/5/16 12:26 PM
 */
public class Test {

    public static void main(String[] args) {

        int[] nums = new int[]{10, 1, 2, 7, 6, 1, 5};
        int target = 8;

        List<List<Integer>> list = new ArrayList<>();
        List<Integer> item = new ArrayList<>();

        generate(nums, item, list, 0, target);

        if (target == 0) {
            list.add(new ArrayList<>());
        }

        System.out.println(list);
    }

    private static void generate(int[] arr, List<Integer> item, List<List<Integer>> list, int start, int target) {

        if (start == arr.length) {
            return;
        }

        item.add(arr[start]);
        List<Integer> item1 = new ArrayList<>();
        item1.addAll(item);
        item1.sort(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o1 - o2;
            }
        });
        if (!isEquals(item1, list) && sumEquals(item1, target)) {
            list.add(item1);
        }

        generate(arr, item, list, start + 1, target);

        item.remove(item.size() - 1);
        generate(arr, item, list, start + 1, target);
    }

    private static boolean sumEquals(List<Integer> list, int target) {
        int num = 0;
        for (int i : list) {
            num += i;
        }
        return num == target;
    }

    private static boolean isEquals(List<Integer> item, List<List<Integer>> list) {

        if (list != null && list.size() > 0) {
            for (List<Integer> l : list) {
                boolean flag = false;
                if (l.size() == item.size()) {
                    for (int i = 0; i < item.size(); i++) {
                        if (item.get(i) != l.get(i)) {
                            flag = false;
                            break;
                        } else {
                            flag = true;
                        }
                    }
                }
                if (flag) return true;
            }
        } else {
            return false;
        }

        return false;
    }
}
```

## 生成括号

给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。

```
例如，给出 n = 3，生成结果为：

[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
```

```java
package com.example.test.alg;

import java.util.ArrayList;
import java.util.List;

/**
 * 功能描述: 生成括号
 *
 * @auther: pikaqiu
 * @date: 2019/5/16 12:26 PM
 */
public class Test {
    public static void main(String[] args) {
        int n = 3;
        List<String> list = new ArrayList<>();
        String item = "";
        generate(list, item, n, 0);
        System.out.println(list);
        isLegal("(())", 2, 4);
    }

    private static void generate(List<String> list, String item, int n, int i) {
        if (i == n * 2) {
            list.add(item);
            return;
        }

        if (isLegal(item + "(", n, i)) {
            generate(list, item + "(", n, i + 1);
        }
        if (isLegal(item + ")", n, i)) {
            generate(list, item + ")", n, i + 1);
        }
    }

    private static boolean isLegal(String str, int n, int i) {

        boolean flag = true;

        int leftNum = 0;
        int rightNum = 0;

        for (int index = 0; index < str.length(); index++) {
            if (str.charAt(index) == '(') {
                leftNum++;
            } else {
                rightNum++;
            }
        }

        if (leftNum > n || rightNum > n || rightNum > leftNum) {
            flag = false;
        }

        return flag;
    }
}
```
