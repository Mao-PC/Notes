# 面试题

## 缓存穿透

如果查询数据在Redis里面查不到, 那么就会去MySQL里去查, 这个现象就是`缓存穿透`

高频的缓存穿透, 会极大的增加数据库压力

**解决方案 1**

> **将查出的数据缓存到Redis中, 即使是null, 这样就会在缓存中查询到**

缺点: 如果每次都使用不同的id查询就不能解决问题, 如 : 使用 -1, -2, -3 ... 或者随机id 查询, 如果使用上面的解决方案, 会适得其反, 就将大量不存在数据保存到Redis中

前置知识: Redis的**内存淘汰机制**:

- volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。
- volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘
- volatile-random：从已设置过期时间的数据集中任意选择数据淘
- volatile-lfu：从已设置过期时间的数据集挑选使用频率最低的数据淘
- allkeys-lru：从数据集中挑选最近最少使用的数据
- allkeys-lfu：从数据集中挑选使用频率最低的数据淘
- allkeys-random：从数据集（server.db[i].dict）中任意选择数据
-  no-enviction（驱逐）：禁止驱逐数据，这也是默认策略。意思是当内存不足以容纳新入数据时，新写入操作就会报错，请求可以继续进行，线上任务也不能持续进行，采用no-enviction策略可以保证数据不被丢失。

这八种大体上可以分为4中，lru、lfu、random、ttl。


**解决方案 2**

> **在Redis和MySQL直接加过滤器, 这个过滤器中保存了数据所有的数据的id值, 如果Redis中没查询到在访问数据库之前过滤器发现没有改id, 直接抛出错误**

缺点: 不是只能通过id来查询, 业务上可能会通过很多条件来查询数据, 如: 名称, 编号.... 如果在过滤器中保存未来可能查询的字段值就会造成内存紧张

## 布隆算法

通过错误率来换取空间的算法(数据标识算法)

Bloom Filter是由Bloom在1970年提出的一种多哈希函数映射的快速查找算法。通常应用在一些需要快速判断某个元素是否属于集合，但是并不严格要求100%正确的场合。

具体为: 在客户端通过id来查询数据, 会将id做hash运算到一个数组中, 可以通过这个数组来判断该id是否存在.

布隆算法的错误率注意体现在:
- 如果数据存在, 那么实际情况可能不存在[hash碰撞]
- 如果数据不存在, 那么一点不存在

**如何降低错误率 ?**

- 错误率主要是因为hash碰撞造成的, 可以来通过增大数组的长度来降低. 数组长度8589934592才会占用1G内存

- hash函数的个数也会影响错误率. 如, 有3个hash函数, 查询id=10的数据, 会通过3个函数分别计算为 1, 5, 10 那么需要下标为1,5,10同时都为1, 才会说明id=10的数据存在. 如果一个id和10的hash结果相同的概率为 (1/length)<sup>3</sup>. 
    
    hash函数的个数也不是越多越好, 一般来说3~5个就可以

**在新增数据时布隆过滤器应该做什么 ?**

为了确保新增的数据能通过过滤器, 需要使过滤器标识新的id, 两个方案:

1. 在新增时, 现在过滤器中标识数据, 然后在数据库中新增
2. 现在数据库中新增, 然后异步在过滤器中标识(如果同步标识的话可能会新增缓慢导致用户体验不好)

推荐第二种方案, 可以使用定时任务每半个小时更新一次过滤器

## 缓存击穿

Redis中数据有效期为1天, 但是在1天后依然为热门数据, 那么1天后查询这个数据的请求就都会去访问数据库.

缓存击穿是缓存穿透的一种特殊形式

**解决方案**

一般不用解决, 一般来说, 中小型公司会因为数据访问量而使数据库垮掉. 如果是大型公司, 如微博, 头条等才用解决的必要

前置知识: 

**分布式锁的使用情况**

- 共享资源
- 共享资源互斥
- 多任务环境

必须满足这3个条件才需要使用分布式锁