# 面试题

## 缓存穿透

如果查询数据在Redis里面查不到, 那么就会去MySQL里去查, 这个现象就是`缓存穿透`

高频的缓存穿透, 会极大的增加数据库压力

**解决方案 1**

> **将查出的数据缓存到Redis中, 即使是null, 这样就会在缓存中查询到**

缺点: 如果每次都使用不同的id查询就不能解决问题, 如 : 使用 -1, -2, -3 ... 或者随机id 查询, 如果使用上面的解决方案, 会适得其反, 就将大量不存在数据保存到Redis中

前置知识: Redis的**内存淘汰机制**:

- volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。
- volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘
- volatile-random：从已设置过期时间的数据集中任意选择数据淘
- volatile-lfu：从已设置过期时间的数据集挑选使用频率最低的数据淘
- allkeys-lru：从数据集中挑选最近最少使用的数据
- allkeys-lfu：从数据集中挑选使用频率最低的数据淘
- allkeys-random：从数据集（server.db[i].dict）中任意选择数据
-  no-enviction（驱逐）：禁止驱逐数据，这也是默认策略。意思是当内存不足以容纳新入数据时，新写入操作就会报错，请求可以继续进行，线上任务也不能持续进行，采用no-enviction策略可以保证数据不被丢失。

这八种大体上可以分为4中，lru、lfu、random、ttl。


**解决方案 2**

> **在Redis和MySQL直接加过滤器, 这个过滤器中保存了数据所有的数据的id值, 如果Redis中没查询到在访问数据库之前过滤器发现没有改id, 直接抛出错误**

缺点: 不是只能通过id来查询, 业务上可能会通过很多条件来查询数据, 如: 名称, 编号.... 如果在过滤器中保存未来可能查询的字段值就会造成内存紧张

## 布隆算法

通过错误率来换取空间的算法(数据标识算法)

Bloom Filter是由Bloom在1970年提出的一种多哈希函数映射的快速查找算法。通常应用在一些需要快速判断某个元素是否属于集合，但是并不严格要求100%正确的场合。

具体为: 在客户端通过id来查询数据, 会将id做hash运算到一个数组中, 可以通过这个数组来判断该id是否存在.

布隆算法的错误率注意体现在:
- 如果数据存在, 那么实际情况可能不存在[hash碰撞]
- 如果数据不存在, 那么一点不存在

**如何降低错误率 ?**

- 错误率主要是因为hash碰撞造成的, 可以来通过增大数组的长度来降低. 数组长度8589934592才会占用1G内存

- hash函数的个数也会影响错误率. 如, 有3个hash函数, 查询id=10的数据, 会通过3个函数分别计算为 1, 5, 10 那么需要下标为1,5,10同时都为1, 才会说明id=10的数据存在. 如果一个id和10的hash结果相同的概率为 (1/length)<sup>3</sup>. 
    
    hash函数的个数也不是越多越好, 一般来说3~5个就可以

**在新增数据时布隆过滤器应该做什么 ?**

为了确保新增的数据能通过过滤器, 需要使过滤器标识新的id, 两个方案:

1. 在新增时, 现在过滤器中标识数据, 然后在数据库中新增
2. 现在数据库中新增, 然后异步在过滤器中标识(如果同步标识的话可能会新增缓慢导致用户体验不好)

推荐第二种方案, 可以使用定时任务每半个小时更新一次过滤器

## 缓存击穿

Redis只有一条数据, 且有效期为1天, 但是在1天后依然为热门数据, 那么1天后查询这个数据的请求就都会去访问数据库.

缓存击穿是缓存穿透的一种特殊形式

**解决方案**

一般不用解决, 中小型公司不会因为数据访问量而使数据库垮掉, 而且即使用n个client同时访问数据库, 也会将查出的数据保存在Redis, 后续的查询都能从Redis中查到, 所以数据库只会承担相对较少的压力, 一般不会垮掉.

 如果是大型公司, 如微博, 头条等才用解决的必要

前置知识: 

**分布式锁的使用情况**

- 共享资源
- 共享资源互斥
- 多任务环境

必须满足这3个条件才需要使用分布式锁, 分布式锁用来解决多个节点上多个进程之间的排队问题

[基于Zookeeper实现分布式锁解决缓存击穿问题](../../mq/zookeeper/Zookeeper实现分布式锁.md)


如果确实需要解决缓存击穿问题, 说明业务上的并发已经很高了, 这时肯定已经有了最基本的并发应对方案, 如: `nginx负载多台tomcat服务器, 也应该有了Redis做数据库缓存`. 在这个基础上, 缓存击穿可以通过**使用分布式锁**来解决. 上面的情况中, 多个client端访问一条在Redis里不存在的数据, 可以先去分布式锁中参与锁竞争, 拿到锁的client就去数据库中查询数据, 然后将数据保存到Redis里, 释放锁后其他的client直接去访问Redis就可以拿到数据.

缺点: 如果并发很高的时候, 锁竞争导致效率较低

## 缓存雪崩

Redis中缓存了多条数据, 都为1天过期, 1天之后这些数据都是热门数据. 在多个client访问时, 会直接访问数据库, 在那一刻数据库会承担巨大的压力. 这就是**缓存雪崩**

`缓存击穿`和`缓存雪崩`的区别: `缓存击穿`是**一条**数据, `缓存雪崩`是**多条数据**, 实际上都是`缓存穿透`

缓存雪崩可能产生的原因: 

1. 有效期一致

2. Redis挂了

**解决方案**

1. 给数据设置不同的有效期

2. Redis集群, 分布式缓存