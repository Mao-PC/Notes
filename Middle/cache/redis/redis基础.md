

[toc]

### 什么是 Redis？简述它的优缺点？

Redis 本质上是一个 **Key-Value 类型的内存数据库**，很像 memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据 flush 到硬盘上进行保存。
因为是纯内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value DB。
Redis 的出色之处不仅仅是性能，Redis 最大的魅力是支持保存多种数据结构，此外单个 value 的最大限制是 1GB，不像 memcached 只能保存 1MB 的数据，因此 Redis 可以用来实现很多有用的功能。
比方说用他的 List 来做 FIFO 双向链表，实现一个轻量级的高性 能消息队列服务，用他的 Set 可以做高性能的 tag 系统等等。
另外 Redis 也可以对存入的 Key-Value 设置 expire 时间，因此也可以被当作一 个功能加强版的 memcached 来用。 Redis 的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。
Redis 作为当前最常用的开源内存数据库，性能十分高，据官方数据表示 Redis 读的速度是 110000 次/s,写的速度是 81000 次/s 。
redis SDS
常数复杂度获取字符串长度：O(1)
杜绝缓冲区溢出
减少修改字符串时带来的内存重分配次数
二进制安全

### Redis 支持的数据类型？

- String 字符串：

  - 格式: set key value

  - string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如 jpg 图片或者序列化的对象 。

  - string 类型是 Redis 最基本的数据类型，一个键最大能存储 512MB。

    

- Hash（哈希）

  - 格式: hmset name key1 value1 key2 value2
  - Redis hash 是一个键值(key=>value)对集合。
  - Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。

  

- List（列表）

  Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）

  - 格式: lpush name value
    在 key 对应 list 的头部添加字符串元素
  - 格式: rpush name value
    在 key 对应 list 的尾部添加字符串元素
  - 格式: lrem name index
    key 对应 list 中删除 count 个和 value 相同的元素
  - 格式: llen name  
    返回 key 对应 list 的长度

  

- Set（集合）

  - 格式: sadd name value
  - Redis 的 Set 是 string 类型的无序集合。
  - 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。

  

- zset(sorted set：有序集合)

  - 格式: zadd name score value
  - Redis zset 和 set 一样也是 string 类型元素的集合,且不允许重复的成员。
  - 不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。
  - zset 的成员是唯一的,但分数(score)却可以重复。

  

- Redis 内部结构

  - dict 本质上是为了解决算法中的查找问题（Searching）是一个用于维护 key 和 value 映射关系的数据结构，与很多语言中的 Map 或 dictionary 类似。 本质上是为了解决算法中的查找问题（Searching）
  - sds sds 就等同于 char _ 它可以存储任意二进制数据，不能像 C 语言字符串那样以字符’\0’来标识字符串的结 束，因此它必然有个长度字段。
  - skiplist （跳跃表） 跳表是一种实现起来很简单，单层多指针的链表，它查找效率很高，堪比优化过的二叉平衡树，且比平衡树的实现，quicklist
  - ziplist 压缩表 ziplist 是一个编码后的列表，是由一系列特殊编码的连续内存块组成的顺序型数据结构，



使用场景

![](C:/Users/mao/Dev/Notes/Middle/cache/redis/res/redis.png)



### 什么是 Redis 持久化？Redis 有哪几种持久化方式？优缺点是什么？

持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。

Redis 提供了两种持久化方式:**RDB（默认）** 和 **AOF**

- **RDB**：rdb 是 Redis DataBase 缩写
  功能核心函数 rdbSave(生成 RDB 文件)和 rdbLoad（从文件加载内存）两个函数
- **AOF**:  Aof 是 Append-only file 缩写
  每当执行服务器(定时)任务或者函数时 flushAppendOnlyFile 函数都会被调用， 这个函数执行以下两个工作aof 写入保存：
  - WRITE：根据条件，将 aof_buf 中的缓存写入到 AOF 文件
  - SAVE：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中。



**存储结构:**
内容是 redis 通讯协议(RESP )格式的命令文本存储。

**比较：**

1. aof 文件比 rdb 更新频率高，优先使用 aof 还原数据。
2. aof 比 rdb 更安全也更大
3. rdb 性能比 aof 好
4. 如果两个都配了优先加载 AOF



### Redis 通讯协议(RESP )，能解释下什么是 RESP？有什么特点？

RESP 是 redis 客户端和服务端之前使用的一种**通讯协议**；

是**基于TCP的应用层协议** RESP(REdis Serialization Protocol)；
RESP底层采用的是TCP的连接方式，通过tcp进行数据传输，然后根据解析规则解析相应信息,

RESP 的特点：**实现简单、快速解析、可读性好**

RESP在Redis中用作请求-响应协议的方式如下：

- 单行字符串 以 + 符号开头。 	 `+hello world\r\n`
- 多行字符串 以 $ 符号开头，后跟字符串长度。   `$11\r\nhello world\r\n`
- 整数值 以 : 符号开头，后跟整数的字符串形式。   `:1024\r\n`
- 错误消息 以 - 符号开头。   `-WRONGTYPE Operation against a key holding the wrong kind of value\r\n`
- 数组 以 * 号开头，后跟数组的长度。 `*3\r\n:1\r\n:2\r\n:3\r\n`



### 什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？



可以参考[redis缓存面试](interview.md)



**缓存穿透**：一般的缓存系统，都是按照 key 去缓存查询，如果不存在对应的 value，就应该去后端系统查找（比如 DB）。一些恶意的请求会故意查询不存在的 key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。

**如何避免？**

1. 对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该 key 对应的数据 insert 了之后清理缓存。
2. 对一定不存在的 key 进行过滤。可以把所有的可能存在的 key 放到一个大的 Bitmap 中，查询时通过该 bitmap 过滤。

<font color="red">实际上这个做法是错误的, 因为这个map可能会无限大, 从而占用过多的内存. 而在redis中插入一个有效期短的值也会同样导致 redis 的频繁操作, 持久化文件也会变得很大</font>



**缓存雪崩**：当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。

**如何避免？**

1. 在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待。
2. 做二级缓存，A1 为原始缓存，A2 为拷贝缓存，A1 失效时，可以访问 A2，A1 缓存失效时间设置为短期，A2 设置为长期
3. 不同的 key，设置不同的过期时间，让缓存失效的时间点尽量均匀。



### 假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？

使用 keys 指令可以扫出指定模式的 key 列表：`keys pre*`

**如果这个 redis 正在给线上的业务提供服务，那使用 keys 指令会有什么问题？**

redis 关键的一个特性：redis 的**单线程**的。keys 指令会导致线程**阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复**。

>  这个时候可以使用 scan 指令，scan 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 keys 指令长。

### 使用过 Redis 分布式锁么，它是什么回事？

先拿 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘记了释放。
这时候对方会告诉你说你回答得不错，然后接着问如果在 setnx 之后执行 expire 之前进程意外 crash 或者要重启维护了，那会怎么样？
这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要抓一抓自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的，然后回答：我记得 set 指令有非常复杂的参数，这个应该是可以同时把 setnx 和 expire 合成一条指令来用的！对方这时会显露笑容，心里开始默念：摁，这小子还不错。
jedis.set(String key, String value, String nx, String expx, int time)，这个 set()方法一共有五个形参：
第一个为 key，我们使用 key 来当锁，因为 key 是唯一的。
第二个为 value，我们传的是 requestId，很多童鞋可能不明白，有 key 作为锁不就够了吗，为什么还要用到 value？<br>原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给 value 赋值为 requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。<br>requestId 可以使用 UUID.randomUUID().toString()方法生成。
第三个为 nx，这个参数我们填的是 NX，意思是 SET IF NOT EXIST，即当 key 不存在时，我们进行 set 操作；若 key 已经存在，则不做任何操作；
第四个为 expx，这个参数我们传的是 PX，意思是我们要给这个 key 加一个过期的设置，具体时间由第五个参数决定。
第五个为 time，与第四个参数相呼应，代表 key 的过期时间。

### 使用过 Redis 做异步队列么，你是怎么用的？

一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。
如果对方追问可不可以不用 sleep 呢？list 还有个指令叫 blpop，在没有消息的时候，它会阻塞住直到消息到来。
如果对方追问能不能生产一次消费多次呢？使用 pub/sub 主题订阅者模式，可以实现 1:N 的消息队列。
如果对方追问 pub/sub 有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 rabbitmq 等。redis 中 pub/sub 缺陷
如果对方追问 redis 如何实现延时队列？
我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：<br>使用有序集合，拿时间戳作为 score，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。

### 如果有大量的 key 需要设置同一时间过期，一般需要注意什么

如果大量的 key 过期时间设置的过于集中，到过期的那个时间点，redis 可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。



### Redis主从复制流程

1. 从服务器通过`psync`命令方式服务器已有的同步进度(同步源ID, 同步进度offset)
2. master收到请求, 同步源为当前master, 则根据偏移量增量同步
3. 同步源非当前master, 则进入全量同步: master生成rdb, 传输到slave, 加载到slave内存

  

**核心知识:** 

- Redis默认使用异步复制, slave和master之间异步地确认处理的数据量
- 一个master可以多个slave
- slave可以接受其他slave的连接. slave可以有下级sub slave
- 主从同步过程在master侧是非阻塞的
- slave初次同步需要删除旧数据, 加载新数据, 会阻塞道路的连接请求



**应用场景:**

- 主从复制可以用来支撑读写分离
- slave服务器设定为只读, 可以用在数据安全的场景下
- 可以使用主从复制来避免mater持久化造成的开销. master关闭持久化, slave配置为不定期保存或是启用AOF. (<font color="red">注意: </font> 重新启动的master程序将从一个空数据集开始, 如果一个slave视图与它同步, 那么这个slave也会被清空)



**主从复制的注意事项**: 

- 读写分离场景: 
  - 数据复制延时到导致读取过去数据或者读不到数据 (网络原因, slave阻塞)
  - 从接到故障 (多个client如何迁移)
- 全量复制情况下:
  - 第一次建立主从关系或者runid不匹配会导致全量复制
  - 故障转移的时候回出现全量复制
- 复制风暴:
  - master故障重启, 如果slave节点较多, 所有slave都要复制, 对服务器性能, 网络的压力都有很大影响
  - 如果一个机器部署了多个master
- 写能力有限:
  - 主从复制还是只有一台master, 提供的写服务能力有限
- master故障的情况下:
  - 如果是master无持久化, slave卡其持久化来保留数据的场景, 建议**不要配置Redis自动重启**
  - 启动Redis自动重启, master启动后, 无备份数据, 可能导致集群数据丢失的情况
  - 当master挂掉之后, 将slave设置为master, 然后在启动原先的master作为新的slave加入集群, 这个过程中, 需要注意:
    - 新的master最好选择没有开启持久化的slave, 这样可以不必让新的master承担写操作
    - 在旧的master启动前, 最好将持久化的slave节点下的数据文件复制到旧的master下, 这样重启的时候直接加载数据, 不需要全量同步数据
- 带有效期的key
  - slave不会让可以过期, 而是在等待master让key过期
  - 在Lua脚本执行期间, 不执行任何key过期操作



### Redis 的同步机制了解么？

Redis 可以使用主从同步，从从同步。第一次同步时，主节点做一次 bgsave，并同时将后续修改操作记录到内存 buffer，待完成后将 rdb 文件全量同步到复制节点，复制节点接受完成后将 rdb 镜像加载到内存。<br>加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。

### redis 常见性能问题和解决方案：

1. Master 写内存快照，save 命令调度 rdbSave 函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以 Master 最好不要写内存快照。

2. Master AOF 持久化，如果不重写 AOF 文件，这个持久化方式对性能的影响是最小的，但是 AOF 文件会不断增大，AOF 文件过大会影响 Master 重启的恢复速度。

   **Master 最好不要做任何持久化工作，包括内存快照和 AOF 日志文件，特别是不要启用内存快照做持久化,如果数据比较关键，某个 Slave 开启 AOF 备份数据，策略为每秒同步一次。**

3. Master 调用 BGREWRITEAOF 重写 AOF 文件，AOF 在重写的时候会占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂服务暂停现象。

4. Redis 主从复制的性能问题，**为了主从复制的速度和连接的稳定性，Slave 和 Master 最好在同一个局域网内**

### 为什么 redis 需要把所有数据放到内存中?

Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以 redis 具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘 I/O 速度为严重影响 redis 的性能。<br>在内存越来越便宜的今天，redis 将会越来越受欢迎。如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。

### redis 的并发竞争问题如何解决?

Redis 为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis 本身没有锁的概念，Redis 对于多个客户端连接并不存在竞争，但是在 Jedis 客户端对 Redis 进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。对此有 2 种解决方法：

1. 客户端角度，为保证每个客户端间正常有序与 Redis 进行通信，对连接进行池化，同时对客户端读写 Redis 操作采用内部锁 synchronized。
2. 服务器角度，利用 setnx 实现锁。

注：对于第一种，需要应用程序自己处理资源的同步，可以使用的方法比较通俗，可以使用 synchronized 也可以使用 lock；第二种需要用到 Redis 的 setnx 命令，但是需要注意一些问题。

### redis 事物的了解 CAS(check-and-set 操作实现乐观锁 )?

和众多其它数据库一样，Redis 作为 NoSQL 数据库也同样提供了事务机制。在 Redis 中，`MULTI/EXEC/DISCARD/WATCH` 这四个命令是我们实现事务的基石。相信对有关系型数据库开发经验的开发者而言这一概念并不陌生，即便如此，我们还是会简要的列出 Redis 中事务的实现特征：

1. 在事务中的所有命令都将会被串行化的顺序执行，事务执行期间，Redis 不会再为其它客户端的请求提供任何服务，从而保证了事物中的所有命令被原子的执行。
2. 和关系型数据库中的事务相比，在 Redis 事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行。
3. 我们可以通过 `MULTI` 命令开启一个事务，有关系型数据库开发经验的人可以将其理解为"BEGIN TRANSACTION"语句。在该语句之后执行的命令都将被视为事务之内的操作，最后我们可以通过执行 `EXEC/DISCARD` 命令来提交/回滚该事务内的所有操作。这两个 Redis 命令可被视为等同于关系型数据库中的 `COMMIT/ROLLBACK` 语句。
4. 在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行 EXEC 命令之后，那么该事务中的所有命令都会被服务器执行。
5. 当使用 Append-Only 模式时，Redis 会通过调用系统函数 write 将该事务内的所有写操作在本次调用中全部写入磁盘。然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也许只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。Redis 服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。此时，我们就要充分利用 Redis 工具包中提供的 redis-check-aof 工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。修复之后我们就可以再次重新启动 Redis 服务器了。



### redis 最适合的场景

Redis 最适合所有数据 in-momory 的场景，虽然 Redis 也提供持久化功能，但实际更多的是一个 disk-backed 的功能，跟传统意义上的持久化有比较大的差别，那么可能大家就会有疑问，似乎 Redis 更像一个加强版的 Memcached，那么何时使用 Memcached，何时使用 Redis 呢?

如果简单地比较 Redis 与 Memcached 的区别，大多数都会得到以下观点：

- Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。

- Redis 支持数据的备份，即 master-slave 模式的数据备份。

- Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。

  

**Redis的优势:**

1. 会话缓存（Session Cache）
   最常用的一种使用 Redis 的情景是会话缓存（session cache）。用 Redis 缓存会话比其他存储（如 Memcached）的优势在于：Redis 提供持久化。
2. 全页缓存（FPC）
   除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，即使重启了 Redis 实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似 PHP 本地 FPC。再次以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。
3. 队列
   Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis 能作为一个很好的消息队列平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言（如 Python）对 list 的 push/pop 操作。如果你快速的在 Google 中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用 Redis 创建非常好的后端工具，以满足各种队列需求。例如，Celery 有一个后台就是使用 Redis 作为 broker，你可以从这里去查看。
4. **排行榜/计数器**
   Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的 10 个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可：当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行：
   `ZRANGE user_scores 0 10 WITHSCORES`
   Agora Games 就是一个很好的例子，用 Ruby 实现的，它的排行榜就是使用 Redis 来存储数据的。
5. 发布/订阅
   最后（但肯定不是最不重要的）是 Redis 的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用 Redis 的发布/订阅功能来建立聊天系统！



### Redis 的数据过期策略是什么？内存淘汰机制都有哪些？

redis 采用的是定期删除+惰性删除策略。

**为什么不用定时删除策略?**

定时删除,用一个定时器来负责监视 key,过期则自动删除。虽然内存及时释放，但是十分消耗 CPU 资源。在大并发请求下，CPU 要将时间应用在处理请求，而不是删除 key,因此没有采用这一策略.



**定期删除+惰性删除是如何工作的呢?**

定期删除，redis 默认每个 100ms 检查，是否有过期的 key,有过期 key 则删除。需要说明的是，redis **不是每个 100ms 将所有的 key 检查一次，而是随机抽取进**行检查(如果每隔 100ms,全部 key 进行检查，redis 岂不是卡死)。因此，如果**只采用定期删除策略，会导致很多 key 到时间没有删除**。
于是，惰性删除派上用场。也就是说在你获取某个 key 的时候，redis 会检查一下，这个 key 如果设置了过期时间那么是否过期了？如果过期了此时就会删除。



**采用定期删除+惰性删除就没其他问题了么?**
不是的，如果定期删除没删除 key。然后你也没即时去请求 key，也就是说惰性删除也没生效。这样，redis 的内存会越来越高。那么就应该**采用内存淘汰机制**。
在 redis.conf 中有一行配置
`maxmemory-policy volatile-lru`

**内存淘汰策略:**

- **noeviction**:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）
- **allkeys-lru**: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。
- **volatile-lru**: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。
- **allkeys-random**: 回收随机的键使得新添加的数据有空间存放。
- **volatile-random**: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。
- **volatile-ttl**: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。

- **allkeys-lfu**：从所有键中驱逐使用频率最少的键
- **volatile-lfu**：从所有配置了过期时间的键中驱逐使用频率最少的键

Redis 中的淘汰机制都是几于近似算法实现的，主要从性能和可靠性上做平衡，所以并不是完全可靠，所以开发者们在充分了解 Redis 淘汰策略之后还应在平时多主动设置或更新 key 的 expire 时间，主动删除没有价值的数据，提升 Redis 整体性能和空间。



**数据恢复阶段过期数据的处理策略**

- RDB : 过期的key不会被持久化到文件中, 再让时过期的key会通过Redis的主动和被动方式清理掉
- AOF : 当Redis使用AOF方式持久化时, 每次遇到过期的key 就会追加一条DEL命令道AOF文件, 也就是说我们只要顺序载入AOF文件就会删除过期的键

### redis 和数据库双写一致性问题

分析: 一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。答这个问题，先明白一个前提。就是如果对数据有强一致性要求，不能放缓存。我们所做的一切，只能保证最终一致性。另外，我们所做的方案其实从根本上来说，只能说降低不一致发生的概率，无法完全避免。因此，**有强一致性要求的数据，不能放缓存**。

回答: 《分布式之数据库和缓存双写一致性方案解析》给出了详细的分析，在这里简单的说一说。首先，采取正确更新策略，**先更新数据库，再<font color="red">删除</font>缓存**。其次，因为可能存在删除缓存失败的问题，**提供一个补偿措施即可，例如利用消息队列**。

### 单线程的 redis 为什么这么快

分析: 这个问题其实是对 redis 内部机制的一个考察。其实根据博主的面试经验，很多人其实都不知道 redis 是单线程工作模型。所以，这个问题还是应该要复习一下的。
回答:主要是以下三点

1. 纯内存操作
2. 单线程操作，避免了频繁的上下文切换
3. 采用了非阻塞 I/O 多路复用机制

题外话：我们现在要仔细的说一说 I/O 多路复用机制，因为这个说法实在是太通俗了，通俗到一般人都不懂是什么意思。博主打一个比方：小曲在 S 城开了一家快递店，负责同城快送服务。小曲因为资金限制，雇佣了一批快递员，然后小曲发现资金不够了，只够买一辆车送快递。

经营方式一:
客户每送来一份快递，小曲就让一个快递员盯着，然后快递员开车去送快递。慢慢的小曲就发现了这种经营方式存在下述问题

- 几十个快递员基本上时间都花在了抢车上了，大部分快递员都处在闲置状态，谁抢到了车，谁就能去送快递
- 随着快递的增多，快递员也越来越多，小曲发现快递店里越来越挤，没办法雇佣新的快递员了
- 快递员之间的协调很花时间

综合上述缺点，小曲痛定思痛，提出了下面的经营方式

经营方式二: 
小曲只雇佣一个快递员。然后呢，客户送来的快递，小曲按送达地点标注好，然后依次放在一个地方。最后，那个快递员依次的去取快递，一次拿一个，然后开着车去送快递，送好了就回来拿下一个快递。

上述两种经营方式对比，是不是明显觉得第二种，效率更高，更好呢。在上述比喻中:

每个快递员------------------>每个线程
每个快递-------------------->每个 socket(I/O 流)
快递的送达地点-------------->socket 的不同状态
客户送快递请求-------------->来自客户端的请求
小曲的经营方式-------------->服务端运行的代码
一辆车---------------------->CPU 的核数

于是我们有如下结论

1. 经营方式一就是传统的并发模型，每个 I/O 流(快递)都有一个新的线程(快递员)管理。
2. 经营方式二就是 I/O 多路复用。只有单个线程(一个快递员)，通过跟踪每个 I/O 流的状态(每个快递的送达地点)，来管理多个 I/O 流。
   我们的 redis-client 在操作的时候，会产生具有不同事件类型的 socket。在服务端，有一段 I/0 多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。
   需要说明的是，这个 I/O 多路复用机制，redis 还提供了 select、epoll、evport、kqueue 等多路复用函数库，大家可以自行去了解。



### redis 哨兵

这里的哨兵有两个作用
通过发送命令，让 Redis 服务器返回监控其运行状态，包括主服务器和从服务器。
当哨兵监测到 master 宕机，会自动将 slave 切换成 master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。
然而一个哨兵进程对 Redis 服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。
用文字描述一下故障切换（failover）的过程。假设主服务器宕机，哨兵 1 先检测到这个结果，系统并不会马上进行 failover 过程，仅仅是哨兵 1 主观的认为主服务器不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行 failover 操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。这样对于客户端而言，一切都是透明的。