[toc]



# Redis 分布式锁



## 什么是分布式锁



- **使用者之间是分布式的**

  <img src="res/分布式锁1.png" alt="分布式锁1" style="zoom:60%;" />

  使用者一/二/三是单独部署的, 锁只有一把

  

  - **好处** : 锁不是单独部署的, 少部署了一个组件

  - **坏处** : 假设部署到了使用者一上,  这样如果使用者一/二/三都来参与锁竞争, 如果使用者二/三就必须要通过网络访问到使用者一内部, 而使用者一只需要调用方法就可以参与锁竞争, 使用者一拿到锁的几率更大



- 使用者和锁直接是分布式的

  

  <img src="res/分布式锁2.png" alt="分布式锁2" style="zoom:60%;" />

  这样可以避免了使用者直接锁竞争的公平, 但是锁会出现单点问题, 如果锁服务挂掉, 那么整个会影响整个系统的使用



- 锁本身是分布式的

  <img src="res/分布式锁3.png" alt="分布式锁3" style="zoom:60%;" />

  锁集群的部署方式能够避免锁的单点问题



## Redlock 实现分布式锁



### 单机版的 Redis 锁



<img src="res/redis锁1.png" alt="redis锁1" style="zoom:60%;" />

**核心要点**: 

- **获取锁**

  ```shell
  SET key value NX PX|EX time
  ```

  - key: 可以是任意的值, 为了能够在分布式使用者直接保持一致, 直接以共享资源命名更好

  - value: **保证每个使用者唯一性**即可

  - NX: redis 关键字, 表示key不存在的时候才能set成功, 保证了不同使用者的**互斥性**

  - PX|EX: 过期时间单位 PX - 毫秒 EX - 秒

    

- **释放锁**

  ```lua
  if redis.call("get", KEYS[1]) == ARGV[1] then
      return redis.call("del", KEYS[1])
  else
      return 0
  end
  ```

  该 Lua 脚本的语义是: 执行这个脚本当输入的 keys[1] 在 redis 的值等于输入的 argv[1] 时, 删除这个原有的key, 即释放锁 (这里查找不到 return 0 也可能是因为过期了)

  - KEYS[1]: 获取锁时输入的 key, 即资源名

  - ARGV[1]: 获取锁输入时的value, 这个**value的唯一性决定了使用者只能删除自身已经获取的锁, 不会误删别人的**

    

- **为什么需要设置锁的过期时间?** 

  给执行的任务一个时间限定, 如果没有完成也需要释放锁.  在如下情况

  - 网络抖动: 在服务A拿到锁并完成任务后, 执行锁释放操作, 这是发生了网络抖动, Redis没有收到删除命令
  - 服务器宕机: 服务A到的锁后宕机, 锁没有释放

  如果不加过期时间, 锁就永远不会释放, 造成死锁

  

- **为什么获取和释放锁需要原子保障**

  如果不使用组合命令:

  ```shell
  SET key value NX PX|EX time
  ```

  而是使用两条命令:

  ```shell
  SETNEX key value
  EXPERE key time
  ```

  这样就不能保证原子性的执行

  

  这样的话如果在执行 `setnx`成功后使用崩溃了, 就不执行`expire`命令来设置过期时间了

  

  同理在释放锁的时候, 也不能将

  ```lua
  if redis.call("get", KEYS[1]) == ARGV[1] then
      return redis.call("del", KEYS[1])
  else
      return 0
  end
  ```

  改为

  ```shell
  get key == value
  del key
  ```

  在执行成功 `get`后服务A崩溃了, 然后在这时锁本服务B获取到后`set`为了新的值, 而这时服务A恢复了, 执行了 `del` 命令, 就会造成误解锁

  

- **单机版 Redis 锁最大的风险是什么**

  单点问题: Redis宕机或网络不通后无法提供服务

  **解决方案**

  - **使用持久化机制** : AOF设置always, 保留每一条用户请求; 如果 redis server 挂了, 这个时候直接重新拉起, 公共 AOF 文件进行恢复

    **风险** : 

    - redis 的持久化并**不一定**能够保证最近的n条数据保存到了文件中, 如果没记录最新的最新的`set`命令, 在重启后就可能导致其他服务获取到锁
    - AOF文件变大后重启需要时间, 可能会导致重启后可能 key 已经过期了

  - **使用主从高可用**

    当主节点挂掉后从节点接收保持锁机制不变

  - **使用 Redlock 分布式锁**

    基于 N 个完全独立的 Redis 节点, 利用分布式高可用系统中大多数存活 (法定人数 quorum 机制) 即可用原则来保证锁的高可用



### Redlock 实现