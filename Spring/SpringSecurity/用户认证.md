[toc]

# SpringSecurity 用户认证



## 设置登录的用户名和密码



三种方式:

- 配置文件
- 配置类
- 自定义编写实现类



**配置文件**

在配置文件 `application.yml` 中设置

```yaml
spring:
  security:
    user:
      name: admin
      password: 123456
```



**配置类**

```kotlin
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder
import org.springframework.security.crypto.password.PasswordEncoder

@Configuration
class SecurityConfig : WebSecurityConfigurerAdapter() {
    override fun configure(auth: AuthenticationManagerBuilder?) {
        if (auth == null) return
        val encoder = BCryptPasswordEncoder()
        val pwd = encoder.encode("111111")
        auth.inMemoryAuthentication().withUser("admin").password(pwd).roles("admin")
    }

    @Bean
    fun password(): PasswordEncoder {
        return BCryptPasswordEncoder()
    }
}
```



配置类的优先级会高于配置类



**自定义**



一般来说用户名和密码时不会再配置文件或者配置类中写死



配置类

```kotlin
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter
import org.springframework.security.core.userdetails.UserDetailsService
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder
import org.springframework.security.crypto.password.PasswordEncoder
import javax.annotation.Resource

@Configuration
class SecurityConfig : WebSecurityConfigurerAdapter() {
    
    @Resource
    private lateinit var userDetailsService: UserDetailsService

    override fun configure(auth: AuthenticationManagerBuilder?) {
        if (auth == null) return
        auth.userDetailsService(userDetailsService).passwordEncoder(password())
    }

    @Bean
    fun password(): PasswordEncoder {
        return BCryptPasswordEncoder()
    }
}
```



数据验证类

```kotlin
import org.springframework.security.core.authority.AuthorityUtils
import org.springframework.security.core.userdetails.User
import org.springframework.security.core.userdetails.UserDetails
import org.springframework.security.core.userdetails.UserDetailsService
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder
import org.springframework.stereotype.Service

@Service
class MyUserDetailsService : UserDetailsService {
    override fun loadUserByUsername(p0: String?): UserDetails {

        // 这里应该是去数据库中查询用户信息, 这里直接硬编码
        val authorityList = AuthorityUtils.createAuthorityList("role")

        return User("admin", BCryptPasswordEncoder().encode("222222"), authorityList)
    }
}
```



在实际的开发过程中, 基本上都采用第三种配置



## demo



demo 采用 `SpringDataJpa` 框架  `kotlin` 语言和 `postgresql` 数据库演示



配置文件

```yaml
server:
  port: 8001
spring:
  datasource:
    url: jdbc:postgresql://localhost:55432/postgres
    username: postgres
    password: 123456
    driver-class-name: org.postgresql.Driver
  jpa:
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
  security:
    user:
      name: admin
      password: 123456
```



entity

```kotlin
import javax.persistence.*

@Entity
class Users {
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "users_seq")
    @SequenceGenerator(sequenceName="users_seq", name="users_seq",allocationSize = 1)
    var id: Int? = null
    var username: String? = null
    var password: String? = null
}
```



dao

```kotlin
import com.lj.ljauth.entity.Users
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.stereotype.Repository

@Repository
interface UserDao : JpaRepository<Users, Int> {
}
```



配置类

```kotlin
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter
import org.springframework.security.core.userdetails.UserDetailsService
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder
import org.springframework.security.crypto.password.PasswordEncoder
import javax.annotation.Resource

@Configuration
class SecurityConfig : WebSecurityConfigurerAdapter() {

    @Resource
    private lateinit var userDetailsService: UserDetailsService

    override fun configure(auth: AuthenticationManagerBuilder?) {
        if (auth == null) return
        auth.userDetailsService(userDetailsService).passwordEncoder(password())
    }

    @Bean
    fun password(): PasswordEncoder {
        return BCryptPasswordEncoder()
    }
}
```



数据库查询实现

```kotlin
import com.lj.ljauth.dao.UserDao
import com.lj.ljauth.entity.Users
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.data.domain.Example
import org.springframework.security.core.authority.AuthorityUtils
import org.springframework.security.core.userdetails.User
import org.springframework.security.core.userdetails.UserDetails
import org.springframework.security.core.userdetails.UserDetailsService
import org.springframework.security.core.userdetails.UsernameNotFoundException
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder
import org.springframework.stereotype.Service

@Service
class MyUserDetailsService : UserDetailsService {

    @Autowired
    lateinit var userDao: UserDao

    override fun loadUserByUsername(username: String?): UserDetails {

        var user = Users()
        user.username = username

        val example = Example.of(user)

        val target: Users
        try {
            target = userDao.findOne(example).get()
        } catch (e: NoSuchElementException) {
            throw UsernameNotFoundException("用户名不存在 !")
        }

      	// 这里没有做权限, 直接写死
        val authorityList = AuthorityUtils.createAuthorityList("role")

        return User(target.username, BCryptPasswordEncoder().encode(target.password), authorityList)
    }
}
```

